[ { "title": "Python - 라이브러리", "url": "/posts/python_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/", "categories": "Language, Python", "tags": "python, library, pip", "date": "2022-05-30 20:05:35 +0900", "snippet": "라이브러리란? 필요한 코드들을 미리 만들어 저장한 함수 집합체 C언어의 #include &amp;lt;stdio.h&amp;gt;와 같이 라이브러리를 불러와서 사용할 수 있다.라이브러리 사용하기 기본적으로 제공하고 있는 라이브러리 : 표준 라이브러리(3.10.4) 라이브러리 호출 : import library_name 라이브러리를 호출하지 않고 사용하는 함수(ex - len(), max(), int(), … )들은 내장함수라고 불린다.라이브러리 설치 기본적으로 설치되어있는 라이브러리 이외에도 다른 라이브러리들이 존재한다. pypig.org에 파이썬에 설치 가능한 외장 라이브러리들의 정보가 있으니, 필요한 라이브러리이름을 찾을 수 있다. 예시) numpy라는 외장 모듈 검색 라이브러리 설치 w. vs code 가상환경으로 파이썬 터미널을 연 것과 같이 파이썬 터미널 열기 터미널에 라이브러리 설치 코드 실행 : pip install numpy 라이브러리 설치 w. cmd win + R cmd python 입력 numpy 설치 라이브러리 사용 예시import numpy # numpy 라이브러리 불러오기arr = numpy.array([[1,2,3],[4,5,6]]) # numpy의 array() 함수 사용print(arr) # [[1 2 3] [4 5 6]]print(type(arr)) # &amp;lt;class &#39;numpy.ndarray&#39;&amp;gt;dir() 라이브러리의 모든 함수를 볼 수 있는 함수 사용 예시) dir(numpy) 결과 : [‘ALLOW_THREADS’, ‘AxisError’, ‘BUFSIZE’, ‘CLIP’, ‘ComplexWarning’, ‘DataSource’, ‘ERR_CALL’, ‘ERR_DEFAULT’, ‘ERR_IGNORE’, ‘ERR_LOG’, ‘ERR_PRINT’, ‘ERR_RAISE’, ‘ERR_WARN’, …, ‘unpackbits’, ‘unravel_index’, ‘unsignedinteger’, ‘unwrap’, ‘use_hugepage’, ‘ushort’, ‘vander’, ‘var’, ‘vdot’, ‘vectorize’, ‘version’, ‘void’, ‘void0’, ‘vsplit’, ‘vstack’, ‘warnings’, ‘where’, ‘who’, ‘zeros’, ‘zeros_like’] 라이브러리 내부 모양 본인이 직접 만들 수도 있음 하나의 파일만 만들 경우, 모듈이라고 한다직접 모듈 생성, 사용 모듈 파일 생성# calc.pydef add(a, b) : return a + bdef sub(a, b) : return a - bdef mul(a, b) : return a * bdef div(a, b) : return a / b 같은 경로의 새 파일 생성 직접 만든 모듈 import# hello.pyimport calcnum = calc.add(10,11)print(num) # 21" }, { "title": "Python - 유용한 함수, 함수 만들기", "url": "/posts/python_%ED%95%A8%EC%88%98/", "categories": "Language, Python", "tags": "python, def, 함수", "date": "2022-05-30 15:00:00 +0900", "snippet": "len() 리스트의 길이를 알 수 있는 함수 사용 예시) l = [1,2,3]s = &#39;hello&#39;print(&#39;l의 길이: %d&#39; %len(l)) # l의 길이: 3print(&#39;s의 길이: %d&#39; %len(s)) # s의 길이: 5 extend() 두 리스트를 합치는 함수 사용 예시) list1 = [1,2,3]list2 = [4,5,6]list1.extend(list2)print(list1) # [1,2,3,4,5,6] del 객체이름 객체를 지울 수 있는 함수 사용 예시) l = [1,2,3]dic = {1:100, 2:200}s = &#39;string&#39;del l[1]print(l) # [1,3] del lprint(l) # NameError: name &#39;l&#39; is not defined.del dic[1]print(dic) # {2:200}del sprint(s) # NameError: name &#39;s&#39; is not defined. append() 리스트에 새로운 값 추가하는 함수 사용 예시) l = [1,2,3]l.append(&#39;hello&#39;)print(l) # [1,2,3,&#39;hello&#39;] sum() 모든 숫자를 더해주는 함수 문자열 사용 시 타입에러 &amp;gt;&amp;gt; TypeError: unsupported operand type(s) for +: ‘int’ and ‘str’ 사용 예시) l = [1,2,3]num = 100sum(l,num) # 1 + 2 + 3 + 100 결과: 106 isdigit() 문자열이 숫자로만 이루어져 있는지 확인하는 함수 사용 예시) s1 = &#39;12345&#39;s2 = &#39;1h246&#39;print(isdigit(s1)) # Trueprint(isdigit(s2)) # False isalpha() 문자열이 문자로만 이루어져 있는지 확인하는 함수 사용 예시) s1 = &#39;abcd1&#39;s2 = &#39;dwgex&#39;print(isalpha(s1)) # Falseprint(isalpha(s2)) # True input() 사용자에게 값을 받을 수 있는 함수 (string 타입) 사용 예시) user = input(&#39;당신의 나이를 적어주세요 : &#39;)print(&#39;당신은 %s살 입니다.&#39; %user) 결과 당신의 나이를 적어주세요 : 22 당신은 22살 입니다. type() 데이터의 타입을 확인하는 함수 사용 예시) s = &#39;string&#39;i = 1f = 1.1l = [1]print(type(s)) # &amp;lt;class &#39;str&#39;&amp;gt;print(type(i)) # &amp;lt;class &#39;int&#39;&amp;gt;print(type(f)) # &amp;lt;class &#39;float&#39;&amp;gt;print(type(l)) # &amp;lt;class &#39;list&#39;&amp;gt; str() 숫자를 문자로 변환하는 함수 사용 예시) num = 123s = str(num)print(type(s)) # &amp;lt;class &#39;str&#39;&amp;gt; int() 문자를 숫자로 변환하는 함수 사용 예시) s = &#39;345&#39;i = int(s)print(type(i)) # &amp;lt;class &#39;int&#39;&amp;gt; max() / min() 입력받은 인수 중 최대(max) 또는 최소(min)값을 리턴하는 함수 사용 예시) l = [24, 99, 120]m = [55, 2, 0]max(l) # 120min(l,m) # 0 함수 만들기# 함수 정의def func_name(param) : statement# 함수 실행func_name(param) def: definition(정의)의 약자인자가 없는 함수def ex1() : statementex1() 예시) def hello(): print(&#39;hello&#39;)hello() # hello 인자가 있는 함수def ex2(param) : statementex2(arg) 예시) def ex2(add_2) : print(add_2 + 2) ex(4) # 6 리턴 값이 있는 함수def ex3() : return 1ex3() 예시) def ex3() : return 4print(ex3()) # 4 더하기 함수 만들기 def add(x, y) : return x + yprint(add(3, 4)) # 7 " }, { "title": "Python - 가상환경 만들기", "url": "/posts/python_%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD/", "categories": "Language, Python", "tags": "python, 가상환경, venv", "date": "2022-05-29 18:33:50 +0900", "snippet": "1. cmd 사용 win + R cmd cd &amp;lt;가상환경 만들 폴더 경로&amp;gt; python -m venv &amp;lt;가상환경이름&amp;gt; 가상환경이 만들어진 모습2. Visual Studio Code(vs code) 사용 vs code 하단 cmd 창 열기 위의 사진과 같은 모양이 없다면 메뉴 중 새로운 터미널 생성 py -3 -m venv &amp;lt;가상환경이름&amp;gt; 가상환경이 만들어진 모습 3. 가상환경 실행(vs code) ctrl + shift + p Python:Select Interpreter (클릭) Enter interpreter path.. (클릭) Find… (클릭) ..\\&amp;lt;가상환경이름&amp;gt;\\Scripts\\python.exe » Select Interpreter ctrl + shift + `사진과 같이 (가상환경이름) root&amp;gt;가 나오면 가상환경 실행 성공! " }, { "title": "Python - 제어문", "url": "/posts/Python-%EC%A0%9C%EC%96%B4%EB%AC%B8/", "categories": "Language, Python", "tags": "python, 제어문, tab", "date": "2022-05-29 16:07:22 +0900", "snippet": "조건문if문if condition : statement1else : statement2 Python의 if문은 Tab이 중요하다. if문의 실행문이 두 개 이상일 경우, 실행문의 들여쓰기는 같아야 한다. if condition : statement1 statement2statement3 # error!else : statement4 예시) if 1 == 0: print(&#39;true&#39;)else : print(&#39;false&#39;) 결과: falseelif문 c, java의 else if문if condition1 : statement1elif condition2 : statement2else : statement3 예시) age = 10if age &amp;gt;= 20 : print(&#39;성인입니다&#39;)elif age &amp;gt;= 10 : print(&#39;10대 입니다&#39;)else : print(&#39;베이비입니다&#39;) 결과: 10대 입니다중첩 if문if condition1: if condition2: statement1 &#39;&#39;&#39; (여러 줄 주석) else : statement2 &#39;&#39;&#39; statement2 # condition2가 아닐 경우 실행 (condition1 = True, condition2 = False)else: statement3 예시) age = 24if age &amp;gt;= 20 : # 20살 이상이면서 if age &amp;gt;= 25 : #25살이 넘었습니다 print(&#39;먹을만큼 먹었습니다&#39;) &quot;&quot;&quot; else : print(&#39;성인입니다&#39;) &quot;&quot;&quot; print(&#39;성인입니다&#39;) # 25살이 넘지 않았습니다else : print(&#39;민증이 없습니다&#39;) 결과: 성인입니다반복문while문while condition: statement 예시) cnt = 0while cnt &amp;lt; 5 : print(cnt) cnt += 1 결과 : 0 1 2 3 4 break break를 만나면 while문 종료 예시) while True: # 무한루프 end = 0 if end == 5 : break # end가 5라면 while문 빠져나가기 print(end) end += 1 결과: 0 1 2 3 4 for문&#39;&#39;&#39; C , Javafor ( int item = 0; item &amp;lt; items.length; item++ ) { statement }&#39;&#39;&#39;for item in items: statement 예시) l = [1, 2, 3, 4]for i in l : print(i) 결과: 1 2 3 4 ★range() 함수 연속되는 숫자를 만들어주는 함수 형태 : range(start, stop, step) stop : 마지막 숫자 + 1 range(5) : 0, 1, 2, 3, 4 start : 시작되는 숫자 range(1, 5) : 1, 2, 3, 4 range(3, 5) : 3, 4 step : 숫자간 간격 range(2, 10, 2) : 2, 4, 8 for문에서 많이 사용됨 예시) for i in range(5): print(i) 결과: 0 1 2 3 4 중첩 for문for item in items: for i in item: statement 예시) 구구단 출력하기for i in range(2, 10) : for j in range(2, 10) : print(&quot;%d x %d = %d&quot; %(i, j, i * j)) 결과: 2 x 2 = 4 2 x 3 = 6 2 x 4 = 8 … 9 x 7 = 63 9 x 8 = 72 9 x 9 = 81 " }, { "title": "Python - 기본 문법", "url": "/posts/python_%EA%B8%B0%EB%B3%B8/", "categories": "Language, Python", "tags": "python, 변수", "date": "2022-05-17 16:20:22 +0900", "snippet": "1. print() 함수 파이썬의 출력함수 사용법 print(&#39;Hello, World!&#39;) 2. 변수 파이썬은 C나 Java와 다르게 변수의 유형을 선언하지 않음 C, Java : int num = 0 Python : num = 0 변수 선언 n = 1 # 숫자형s = &#39;hello&#39; # 문자형true = True # 불린형l = [ 1, &#39;a&#39;, 5.2 ] # 리스트형dic = { &quot;key&quot;: &quot;value&quot; } # 딕셔너리형 bool True, False &amp;gt;&amp;gt; ★첫 글자는 무조건 대문자list 한 가지 유형밖에 넣지 못하는 C나 Java와 다르게 여러 형태의 요소 입력 가능 list_name = [ 13, &#39;string&#39;, False, { &quot;dic&quot;:9 }, [ &#39;list&#39;, 0 ] ] 순서가 있는 유형 : index 사용 가능 예시) list_n = [ 1, 2, 3 ]print(list_n[0]) 결과: 1 dictionary 다른 언어와 마찬가지로 “키”,”값”이 한 쌍으로 이루어져있는 유형 순서가 없는 유형 : index 사용 불가, key로 value를 호출 예시) dic = { &quot;a&quot;:10, &quot;b&quot;:20 }print(dic[ &quot;a&quot; ]) 결과: 10 3. 연산n = 3s = &quot;3&quot;# 숫자 + 문자print( n + s ) # TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;# 숫자 + 숫자print( n + n ) # 6# 문자 + 문자print(s + s ) # 33" }, { "title": "JavaScript - 기능 정리", "url": "/posts/js)%EA%B8%B0%EB%8A%A5%EB%93%A4/", "categories": "Language, Front-End", "tags": "js, func, jquery", "date": "2022-04-21 00:28:40 +0900", "snippet": "경고창 띄우기&amp;lt;script&amp;gt; function hello() { alert(&#39;안녕&#39;) }&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- oneclick : 버튼 클릭 시 hello() 함수 실행 --&amp;gt; &amp;lt;button onclick=&quot;hello()&quot; type=&quot;button&quot;&amp;gt;hello&amp;lt;/button&amp;gt;&amp;lt;/body&amp;gt; 결과 : 크롬 콘솔창 열기 ctrl-shif-j 마우스 우클릭 &amp;gt;&amp;gt; 검사 &amp;gt;&amp;gt; Elements(요소) 옆 Console(콜솔) 클릭 콘솔 출력&amp;lt;script&amp;gt; console.log(&#39;hello&#39;)&amp;lt;/script&amp;gt; html script로 실행한 결과 크롬 콘솔창에서 실행한 결과 (js) 요소의 id 사용&amp;lt;script&amp;gt; document.getElementId(&quot;id_name&quot;)&amp;lt;/script&amp;gt; 예시) 요소의 id를 이용해 css 스타일 변경하기 &amp;lt;script&amp;gt; var chage = document.getElementById(&quot;change&quot;) change.style.height = &quot;800px&quot; // div의 높이가 800px로 바뀜 &amp;lt;/script&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;change&quot; style=&quot;background: pink&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; (jQuery) input내용 조작 : $(‘선택자’).val() 선택한 요소의 값을 설정 또는 반환&amp;lt;script&amp;gt; // input의 내용 콘솔에 출력 function print() { let value = $(&#39;input&#39;).val() console.log(value) } // input의 내용 &#39;바뀌어라!&#39;로 변경 function change() { $(&#39;input&#39;).val(&#39;바뀌어라!&#39;) }&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; &amp;lt;input type=&quot;text&quot;&amp;gt; &amp;lt;button onclick=&quot;print()&quot; type=&quot;button&quot;&amp;gt;input내용 출력&amp;lt;/button&amp;gt; &amp;lt;button onclick=&quot;change()&quot; type=&quot;button&quot;&amp;gt;input내용 변경&amp;lt;/button&amp;gt;&amp;lt;/body&amp;gt; input내용 출력 결과 input내용 변경 결과 (jQuery) 요소의 텍스트내용 조작 : $(‘선택자’).text() 선택 요소의 텍스트 설정 또는 반환&amp;lt;script&amp;gt; // h3 내용 출력 function h3() { let h3 = $(&#39;h3&#39;).text() alert(h3) // 경고창 띄우기 } // h4 내용 변경 function h4() { $(&#39;h4&#39;).text(&#39;h4 변경!&#39;) }&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h3&amp;gt;h3 내용&amp;lt;/h3&amp;gt; &amp;lt;h4&amp;gt;h4 내용&amp;lt;/h4&amp;gt; &amp;lt;button onclick=&quot;h3()&quot; type=&quot;button&quot;&amp;gt;h3텍스트출력&amp;lt;/button&amp;gt; &amp;lt;button onclick=&quot;h4()&quot; type=&quot;button&quot;&amp;gt;h4텍스트변경&amp;lt;/button&amp;gt;&amp;lt;/body&amp;gt; 결과 (jQuery) 요소의 내부 조작 : $(‘선택자’).html() text() : 태그 내부의 문자열만 가져옴 html() : 선택자 내부의 태그 및 문자열 모두 가져옴 ex) &amp;lt;script&amp;gt; function txt() { alert($(&quot;.dif&quot;).text()) } function htm() { alert($(&#39;.dif&#39;).html()) } &amp;lt;/script&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;dif&quot;&amp;gt; &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;bye&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button onclick=&quot;txt()&quot;&amp;gt;text()&amp;lt;/button&amp;gt; &amp;lt;button onclick=&quot;htm()&quot;&amp;gt;html()&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; 결과 txt() 버튼 클릭 시 hello bye html() 버튼 클릭 시 &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;bye&amp;lt;/p&amp;gt; html()로 내부 조작하기&amp;lt;script&amp;gt; var operation = &#39;hola&#39; $(&quot;.dif&quot;).html(&#39;&amp;lt;h1&amp;gt;&#39;+ operation + &#39;&amp;lt;/h1&amp;gt;&#39;)&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;dif&quot;&amp;gt; &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;bye&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt; 실행 결과 : hola .dif 내부의 내용이 &amp;lt;h1&amp;gt;operation&amp;lt;/h1&amp;gt;로 바뀜 + ‘&amp;lt;h1&amp;gt;’+ operation + ‘&amp;lt;/h1&amp;gt;’ = `&amp;lt;h1&amp;gt;${operation}&amp;lt;/h1&amp;gt;`속성 조작element.attr(‘attribute’, ‘value’) : 속성 추가&amp;lt;script&amp;gt; $(&#39;h1&#39;).attr(&#39;title&#39;, &#39;add_title&#39;)&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt; 결과(콘솔 확인): &amp;lt;h1 title=”add_title”&amp;gt;hello&amp;lt;/h1&amp;gt;element.removeAttr(‘attributeName) : 속성 삭제&amp;lt;script&amp;gt; $(&#39;h1&#39;).removeAttr(&#39;title&#39;)&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; &amp;lt;h1 title=&quot;add_title&quot;&amp;gt;hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt; 결과(콘솔 확인): &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt;" }, { "title": "Ajax", "url": "/posts/ajax)%EA%B8%B0%EB%B3%B8-%ED%8B%80/", "categories": "Language, Front-End", "tags": "Ajax", "date": "2022-02-05 00:09:34 +0900", "snippet": "기본 골격$.ajax({ type: &quot;GET&quot;, // GET방식 요청, &quot;POST&quot;:POST방식 요청 url: &quot;연결할 url&quot;, // &quot;/&quot;:home, &quot;/search&quot;, &quot;name.html&quot; ... data: {}, // GET방식일 경우 비워넣기, POST에서만 사용 success: function(response) { // 요청결과 response에 담기 // 요청결과에 대해 실행할 코드 }})GET 방식 주로 데이터 조회 요청 ? : ‘?’다음부터 전달할 데이터 &amp;amp; : 데이터가 또 있다(a=A&amp;amp;b=B&amp;gt;&amp;gt; a와 b의 데이터) url의 주소로 사용됨 정보를 담을 수 있는 길이가 한정적(최대 2048자) ex) 구글 검색 : 염소 https://www.google.com/search?q=염소&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8 https://www.google.com/search : 구글의 ‘\\/search’로 데이터 전달 q=염소 : 검색어=염소 sourceid=chrome : 브라우저 정보 ie=UTF-8 : 인코딩정보 $.ajax({ type: &quot;GET&quot;, url: &quot;/test?name=gildong&quot;, // &quot;/test&quot;라는 url로 연결, 데이터는 {&#39;name&#39;:&#39;gildong&#39;} data: {}, success: function(response) { console.log(response) // 결과를 콘솔창에 출력 }})POST 방식 주로 데이터 생성, 변경, 삭제 요청 회원정보같은 예민한 데이터는 POST로 url에 표시되지 않고 전송 크기가 큰 데이터 전송 시 POST 사용$.ajax({ type: &quot;POST&quot;, url: &quot;/test&quot; // test라는 url로 연결 data: {&quot;name&quot;:&quot;gildong&quot;} // 키 = name, 값 = gildong success: function(response) { console.log(response) }})" }, { "title": "JavaScript - 함수, 제어문", "url": "/posts/js)%ED%95%A8%EC%88%98,-%EC%A0%9C%EC%96%B4%EB%AC%B8/", "categories": "Language, Front-End", "tags": "js, 함수, 제어문", "date": "2022-02-03 23:57:30 +0900", "snippet": "함수함수 만들기function fname(param) { // param 생략 가능 statement return // 생략가능}함수 사용하기// 함수 실행fname(param)// 함수를 값으로 가진 변수 생성let func = fname(param)조건문(if)기본if(condition) { // 조건에 맞으면 statement // 실행}// 아니면 빠져나옴else 기본 조건이 맞지 않을 때 실행if(condition) { statement1 // true 실행문} else { statement2 // false 실행문}else if 기본 조건 이외의 다른 조건 추가if(condition1) { statement1 // 조건1에 부합하면 실행} else if(condition2) { statement2 // 조건2에 부합하면 실행} else { statement3 // 모든 조건에 맞지 않다면 실행}중첩 if문 if문 안에 if문 존재if(condition1) { // 조건1에 부합하면 if(condition1_1) { // 조건1과 조건1-1에 부합한가? statement1 // 그러면 실행 } else { // 조건1에만 부합한가? statement2 // 그러면 실행 }} else { statement3 // 조건1에 부합하지 않으면 실행}반복문(for) for(초기문; 조건문; 증감문) { 실행문 }for(let i=0; i&amp;lt;10; i++) { // i가 10보다 작을 때 까지 i를 1씩 증가시키며 반복한다. console.log(i) // 콘솔창에 출력(=printf())} 결과: 0 1 2 3 4 5 6 7 8 9 " }, { "title": "JavaScript - 변수", "url": "/posts/js)%EB%B3%80%EC%88%98/", "categories": "Language, Front-End", "tags": "js, let, 변수", "date": "2022-02-03 23:08:56 +0900", "snippet": "변수선언 형태let varName1 = value;let varName2 = value // 세미콜론을 꼭 넣을 필요는 없다. javascript는 C나 JAVA처럼 타입을 지정하지 않는다. ex) int x;  char y;   etc… 숫자형let num = 10 // 정수let f = 1.0 // 실수문자형let chr1 = &quot;10&quot;let chr2 = &#39;10&#39; // 큰따옴표(&quot;&quot;), 작은따옴표(&#39;&#39;)모두 사용 가능 따옴표가 없다면 변수로 인식 let hey = bro // bro라는 변수를 hey의 값으로 지정let hey = &#39;bro&#39; // hey의 값은 bro 문자열 내부 따옴표let hello = &quot;Hello &#39;World&#39;&quot; // Hello &#39;World&#39;let bye = &#39;Bye &quot;World&quot;&#39; // Bye &quot;world&quot;let two = &#39;\\&#39;Hello\\&#39; World&#39; // &#39;Hello&#39; World 따옴표는 짝이 맞아야 한다! let single = &quot;apple &#39;is delicious&#39; // error! 외부, 내부 같은 따옴표 사용(escape문자 이용) ’\\‘작은따옴표가 두 개! ‘\\’ » ‘작은 따옴표가 두 개!’ escape문자 : \\ 불린형let yes = truelet no = false 대문자(True) 사용 시 변수명으로 인식리스트형let arr = [] // 빈 리스트 선언let arr2 = [&#39;1&#39;, 2, 3, &#39;4&#39;] // 다른 자료들도 사용 가능arr2[0] // 리스트의 첫 index &#39;1&#39;리스트형 함수 요소 추가arr.push(5) // arr = [5] 리스트 길이 구하기arr.length // 1 두 리스트 합치기let arr3 = arr.concat(arr2) // arr에 arr2를 합침// arr3 = [5, &#39;1&#39;, 2, 3, &#39;4&#39;]딕셔너리형 C언어의 structure와 비슷한 형태 { key : value }의 형태로 이루어짐let dict1 = {} // 빈 딕셔너리 선언let personal = { &#39;name&#39;:&#39;gildong&#39;, &#39;age&#39;: 300 }personal[&#39;name&#39;] // gildong 딕셔너리 추가dict1[&#39;add&#39;] = &#39;hello&#39; // dict1 = {&#39;add&#39;:&#39;hello&#39;} 딕셔너리 배열로 합치기let arr = []arr.push(dict1, personal) // push(추가하고 싶은, 요소, 여러 개, 삽입, 가능)// 결과 : arr = [{&#39;add&#39;:&#39;hello&#39;},{&#39;name&#39;:&#39;gildong&#39;, &#39;age&#39;:300}] arr의 gildong 지정 &amp;gt;&amp;gt; arr[1][‘name’] arr[0] : {‘add’:’hello’} arr[0][‘add’] : hello" }, { "title": "포스팅 제목때문에 생긴 이상들", "url": "/posts/%ED%8F%AC%EC%8A%A4%ED%8C%85-%EC%98%A4%EB%A5%98/", "categories": "Blog", "tags": "tag", "date": "2022-01-26 01:28:48 +0900", "snippet": "Error: Process completed with exit code 1.포스팅 열심히 써서 commit 했는데 처음으로 오류가 났다.인터넷에 찾아봤지만 못 찾았다. 영어해석에 실패해서 못 찾았다당황스러웠지만 혹시 몰라 에러 메세지의 맨 윗부분을 읽어보았다.에러가 난 부분 : ★invalid attribute name &quot;포맷&quot;★아.. 큰따옴표(““)가 포스팅 제목으로는 사용불가 문자였다.포스팅 제목의 큰따옴표를 지우고 다시 commit 했더니 포스팅 성공!포스팅 타이틀에 ‘[ ]’사용에러는 나지 않았지만 commit이 이상했다.브랜치를 만든 적도, 병합한 적도 없는데?혹시나 하고 포스팅을 확인해보니, 정상적으로 완료된 포스팅과 다른 점이 있었다.좌: 잘못된 포스팅 우: 정상적으로 완료된 포스팅카테고리와 태그에 [ ]형식이 쓰이는데, 혹시 이것때문에 얘가 잘못 인식한건가 싶었다.블로그에 들어가보니 글은 올라왔지만 포스팅 제목이 없었다.예상이 맞는지 확인하기 위해 포스팅 타이틀에 [ ]를 지웠다.업데이트 제대로 완료!블로그도 제목 제대로 입력 완료! 22.05.29 추가특수문자’&amp;lt;&amp;gt;’ 오류 html의 태그를 나타내기위해 사용되는 ‘&amp;lt;&amp;gt;‘기호를 특수문자가 아닌 그냥 사용하려고 했었으나 오류가 났다. &amp;lt;강조표시를 위해 사용한 기호&amp;gt; &amp;gt;&amp;gt; error! \\&amp;lt;사용하는 법\\&amp;gt; 특수문자 \\ 사용하기!" }, { "title": "HTML - Sample image-placeholder", "url": "/posts/HTML)sample-image-placeholder/", "categories": "Language, Front-End", "tags": "HTML, img", "date": "2022-01-25 23:55:55 +0900", "snippet": "img tag 이미지 삽입 태그 사용법&amp;lt;img src=&quot;이미지주소&quot; alt=&quot;src오류시 나오는 내용&quot;&amp;gt;▶ src 넷상의 이미지 주소를 가져올 때&amp;lt;!-- 이미지주소 변경되면 에러! --&amp;gt;&amp;lt;img src=&quot;https://images.pexels.com/photos/2449543/pexels-photo-2449543.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;dpr=2&amp;amp;h=750&amp;amp;w=1260&quot;&amp;gt; 결과 Aaron Burden 님의 사진, 출처: Pexels 컴퓨터에 저장되어 있는 이미지를 가져올 때&amp;lt;!-- 경로 설정 주의! --&amp;gt;&amp;lt;img src=&quot;../../../assets/imgs/html_01_00.jpg&quot;&amp;gt; 결과 Bekir Donmez 님의 사진, 출처: Pexels ▶ alt(이미지 오류) &amp;lt;img src=&quot;&quot; alt=&quot;이미지 없다&quot;&amp;gt; 샘플 이미지 사용하기 https://via.placeholder.com 주로 임시로 이미지의 크기, 위치 등을 설정할 때 사용사용방법 &amp;lt;img src=&quot;https://via.placeholder.com/200&quot; alt=&quot;200x200&quot;&amp;gt;&amp;lt;!-- 200 x 200 샘플 이미지 생성 --&amp;gt; 결과 : 가로 세로 다른 크기 설정 &amp;lt;img src=&quot;https://via.placeholder.com/200x300&quot; alt=&quot;200x300&quot;&amp;gt; 가로x세로 결과 : 확장자 지정(png, jpg, jpeg, gif) &amp;lt;!-- jpg --&amp;gt;&amp;lt;img src=&quot;https://via.placeholder.com/200x300.jpg&quot;&amp;gt;&amp;lt;!-- png --&amp;gt;&amp;lt;img src=&quot;https://via.placeholder.com/200x300.png&quot;&amp;gt;&amp;lt;!-- gif --&amp;gt;&amp;lt;img src=&quot;https://via.placeholder.com/200x300.gif&quot;&amp;gt; 결과 : 이미지 내부 텍스트 입력 &amp;lt;img src=&quot;https://via.placeholder.com/200?text=this+is+test&quot;&amp;gt; 띄어쓰기 부호 : + hello,+world &amp;gt;&amp;gt; hello, world 결과 : 이미지 색상, 글자 색상 지정 &amp;lt;img src=&quot;https://via.placeholder.com/200/000000/ffffff?text=img+color,+txt+color&quot;&amp;gt; placeholder주소/이미지크기/이미지색상/폰트색상?텍스트 색상 : hex color code 사용 결과 : " }, { "title": "C언어 공부 정리(10/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(10-3)/", "categories": "Language, C", "tags": "공부, C, 연습문제", "date": "2022-01-23 23:51:00 +0900", "snippet": "22/01/12main(int argc, char* argv[])을 이용해 파일 생성 후 글 쓰기, 복사, 읽기 main(int argc, char* argv[])란 : 링크 실행할 문자 실행 결과 frw frw출력 frw @ test.txt test.txt 글쓰기 frw test.txt test.txt 내용 읽기 frw test.txt test2.txt test.txt의 내용을 test2.txt에 복사 파일명 : frw argv[]의 개수에 따라 위의 모든 기능을 제어(한 프로그램으로 만들기)소스코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;int main(int argv, char* argv[]) { FILE *in, *out; char c; // argv[] 크기 1개 : argv[] 모니터에 출력 if(argc == 1) while((c = getc(stdin)) != &#39;\\n&#39;) putc(c, stdout); // argv[] 크기 2개 : txt내용 읽기 else if(argc == 2) { // 파일 읽기모드 시 파일 없으면 에러가 나므로 에러 처리 if((out = fopen(argv[1], &quot;r&quot;)) == NULL) { printf(&quot;%s열기를 실패했습니다.\\n&quot;, argv[1]); exit(1); } while((c=getc(out)) != EOF) // out에 EOF를 만나기 전까지 문자 가져오기 putc(c, stdout); // 모니터에 가져온 문자 출력 fclose(out); } // argv[] 크기 3개 else if(argc == 3) { // @ txt : txt 쓰기모드, 키보드로 받은 문자 txt에 입력 if(!strcmp(argv[1], &quot;@&quot;)) { // argv[1]과 @가 0(F)이라면&amp;gt;&amp;gt;strcmp 결과 0 : 같은 문자 // txt를 쓰기모드로 여는데 오류가 있다면 if((in = fopen(argv[2, &quot;w&quot;])) == NULL) { printf(&quot;%s열기를 실패했습니다.\\n&quot;, argv[2]); exit(2); } while((c = getc(stdin)) != EOF) // 키보드에 `ctrl-z`가 눌리기 전까지 putc(c, in); // txt에 문자 입력 fclose(in); } // argv[1]의 txt 내용을 argv[2]의 txt에 복사 else { // argv[1]파일이 없거나 오류가 있다면 if((in = fopen(argv[1],&quot;r&quot;)) == NULL) { printf(&quot;%s열기를 실패했습니다.\\n&quot;, argv[1]); exit(3); } // argv[2]파일을 쓰기모드로 여는데 오류가 있다면 if((out = fopen(argv[2], &quot;w&quot;)) == NULL) { printf(&quot;%s열기를 실패했습니다.\\n&quot;, argv[2]); exit(4); } while((c = getc(in)) != EOF) // argv[1]에 EOF를 만나기 전까지의 문자를 putc(c, out); // argv[2]에 입력 fclose(out); fclose(in); } } // 모든 경우의 수가 아닐 경우 else { printf(&quot;잘못된 입력입니다\\n&quot;); exit(5); } return 0;}결과 frw 결과 : frw frw test.txt test.txt 없을 경우 : test.txt열기를 실패했습니다. test.txt 있을 경우 : test.txt내용 모니터에 출력 frw @ test.txt hello, world (입력) 결과 : test.txt 생성, 내용 입력(hello, world) frw test.txt test1.txt 결과 : test1.txt 생성, test.txt의 내용(hello, world)이 test1.txt에 입력 frw test1.txt 결과 : test1.txt의 내용 출력 " }, { "title": "C언어 공부 정리(10/10)-FILE I/O", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(10-2)/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-23 02:47:20 +0900", "snippet": "22/01/121. fgets(), fputs()1. fgets() 형태 : fgets(char* str, int num, FILE * stream); 파일 스트림에서 (num-1)만큼의 문자열을 받아 str에 저장하는 함수 파일 끝을 읽거나 오류 발생 시 return NULL ex)char c[80];fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); // 파일 읽기 전용 열기if(fp == NULL) // 파일에 오류 발생 시 perror(&quot;파일 여는 것을 실패했습니다.&quot;); // 오류메세지 출력 : 발생한 에러 메세지else { fgets(c, 80, fp); // fp의 내용을 크기 80까지 읽어오고 c에 내용 저장 puts(c); // 모니터에 문자열 c 출력}fclose(fp); // 사용 끝난 후 파일 닫기 test.txt 존재 시(내용 : hello, world) 결과 : hello, world test.txt 미 존재 시 결과 : 파일 여는 것을 실패했습니다. : 에러 메세지 2. fputs() 형태 : fputs(char* str, FILE * stream); 파일 스트림에 str 입력 오류 시 return EOF ex)char c[80];fgets(c, 80, stdin); // 키보드(stdin)의 내용을 크기 80까지 읽어오고 c에 내용 저장fp = fopen(&quot;test.txt&quot;, &quot;w&quot;); // 파일 쓰기 전용 열기(파일 없으면 새로 생성)fputs(c, fp); // fp에 c의 내용 입력fclose(fp); 결과 : fgets()로 사용자에게 입력받은 문자열이 fp에 추가됨2. fgets() vs gets(), fputs() vs puts()fgets(), gets() fgets() : \\n 추가 gets() : \\0 추가 함수 abc\\n(문자열 얻기) fgets() abc\\n\\0 gets() abc\\0 ex) test.txt내용 : hello, worldchar c[] = &quot;bye, world&quot;;// fgets()printf(&quot;fgets()\\n&quot;);fgets(c, 80, stdin);fp = fopen(&quot;test.txt&quot;, &quot;w&quot;);fputs(c, fp);fclose(fp);printf(&quot;\\n&quot;);// gets()printf(&quot;gets()\\n&quot;);gets(c);fp = fopen(&quot;test.txt&quot;, &quot;w&quot;);fputs(c, fp);fclose(fp); 결과 fgets()hello, worldbye, world gets()hello, worldbye,world fputs(), puts() fputs() : fp에 문자열 입력, \\n없음 puts() : 모니터에 문자열 출력 함수 abc\\0 fputs() abc puts() abc\\n ex)fputs(&quot;hello1&quot;, stdout); // stdout : 모니터fputs(&quot;bye1&quot;, stdout);printf(&quot;\\n&quot;);puts(&quot;hello2&quot;);puts(&quot;bye2&quot;); 결과 hello1bye1 hello2 bye23. I/O 함수1. int fseek(fp, offset, origin); 파일(fp)의 어디서부터(origin) 몇 번째(long int offset)에 커서를 옮기는 함수 origin 종류 모드 값 파일에서의 위치 SEEK_SET 0 파일의 시작(처음) SEEK_CUR 1 현재 위치 SEEK_END 2 파일의 끝 ex) test.txt 내용 : 123456789abcdefchar c[80];fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); // 파일 읽기 모드 열기fgets(c, 80, fp);puts(c);fseek(fp, 7, SEEK_SET); // 커서를 파일의 처음에서 7번째로 이동fgets(c, 80, fp);puts(c);fclose(fp); 결과 123456789abcdef //fseek 사용 전89abcdef // fseek 사용 후 fseek(fp, -4, SEEK_END); &amp;gt;&amp;gt; 파일의 끝에서 왼쪽으로 네 번 커서 이동 ’-‘부호는 커서가 왼쪽으로 이동 양수는 커서가 오른쪽으로 이동 2. int ftell(fp); 현재 커서의 위치 반환 ex)fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);fseek(fp, 2, 0); // 0,1,2로도 origin을 설정할 수 있음printf(&quot;현재 커서 위치 = %d&quot;,ftell(fp)); 결과 : 현재 커서 위치 = 2 전체를 다 읽고(puts(), fputs()) 사용하면 끝의 커서 위치 반환3. int fflush(fp); buffer에 출력되지 않은 데이터들을 모조리 출력해 buffer를 비우는 함수4. int setvbuf(fp, char *buf, int mode, size_t size); 원래 있는 버퍼가 아닌 다른 버퍼를 사용하는 함수 많이 사용하지 않는다고 한다. 파일(fp)을 어떤 모드(mode)의 크기가 size(버퍼 크기)인 다른 버퍼(*buf)를 사용한다. mode : 버퍼의 모드 설정 _IOFBF : Full buffer &amp;gt;&amp;gt; 버퍼가 가득차면 출력 _IOLBF : Line buffer &amp;gt;&amp;gt; \\n을 기준이로 출력 _IONOBUF : No buffer &amp;gt;&amp;gt; 버퍼 미사용(바로바로 출력) 5. freopen(fileName, mode, fp); 파일을 닫았다가 사용하는 것이 아닌 사용중에 다시 여는 함수 사용하는 파일(fileName)과 같은 파일(fp)에 어떠한 모드(mode)로 다시 열것인가? fp = fopen(&quot;test.txt&quot;, &quot;w&quot;); // 쓰기모드로 열기fp = freopen(&quot;test.txt&quot;, &quot;r&quot;, fp); // 읽기모드로 다시 열기 사용하는 파일(fileName)과 다른 파일(fp)에 어떠한 모드(mode)로 다시 열것인가? fp = fopen(&quot;test.txt&quot;, &quot;w&quot;); // 쓰기모드로 열기fp = freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout); // 모니터로 쓰기모드 재오픈printf(&quot;abcd&quot;); // 모니터에 프린트된 &#39;abcd&#39;가 test.txt에 입력됨fclose(fp); " }, { "title": "C언어 공부 정리(10/10)-printf(포맷) 형태", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(10-1)/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-22 17:56:09 +0900", "snippet": "22/01/121. 기본적인 printf(“포맷”)형태printf(&quot;%포맷\\n&quot;, 변수); 변수를 포맷에 맞춰 출력2. &quot;%n.mf&quot; : 실수 표현 방식 n : 전체자리수 m : 소수점 이하 표현 수 ex) printf(&quot;%7.1f&quot;,1234.5678); // 1234.6 7 : _ _ _ _ _ _ _ 7자리 확보 &amp;gt;&amp;gt; 1 2 3 4 . 5 6 .1 : 소수점 첫번째 자리까지만 표현 &amp;gt;&amp;gt; 1234.6(컴퓨터는 실수를 완벽하게 표현 못 함) 7.1f 결과 : _1234.6 3. &quot;%n.ms&quot; : 문자열 포맷 %s : 문자열 출력 n : 최소한으로 나와야 하는 자리 수 m : 찍어주는 자리 수 ex) char c[] = &quot;hello, world&quot;;printf(&quot;%10s&quot;,c); // hello, worldprintf(&quot;%15s&quot;,c); // hello, worldprintf(&quot;%-15s&quot;,c); // hello, world printf(&quot;%.10s&quot;,c); // hello, wor strlen(c) : 12 10s : 최소 10자리 이상 &amp;gt;&amp;gt; c는 12자리 &amp;gt;&amp;gt; hello, world 15s : 최소 15자리 이상 &amp;gt;&amp;gt; c는 12자리 &amp;gt;&amp;gt; _ _ _ hello, world(앞 세자리 확보) -15s : 최소 15자리 이상 &amp;gt;&amp;gt; c는 12자리 &amp;gt;&amp;gt; hello, world _ _ _(뒤 세자리 확보) .10s : 찍어줄 수 있는 최대의 자리 수 &amp;gt;&amp;gt; c는 12자리 &amp;gt;&amp;gt; hello, wor(10자리까지만 찍힘) " }, { "title": "C언어 공부 정리(9/10)-FILE I/O", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(9-3)/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-22 02:31:16 +0900", "snippet": "22/01/111. Formatted I/O1. scanf() 입력함수 사용법 scanf(“포맷형식”, 변수의 주소); 정수 : scanf(“%d”, &amp;amp;num); 문자 : scanf(“%s”, &amp;amp;char); 배열 : scanf(“%s”, arr); / scanf(“%d”, arr);  // 배열의 이름 : 주소 두 개 이상을 입력 받을 때 scanf(“%s %s”, str, &amp;amp;ch); &amp;gt;&amp;gt; %s %s 사이에 콤마 찍지 않아도 괜찮음 2. printf() 출력함수 사용법 printf(“포맷형식”, 변수명); 정수 : printf(“%d”, num); 문자 : printf(“%s”, char); 배열 : printf(“%s”, arr); / printf(“%d”, arr); 두 개 이상을 입력 받을 때 printf(“%s, %s”,str, ch); 2. Unformatted I/O1. getc() 한 문자를 가져오는 함수 한 문자를 가져오고 내부적으로 다음 문자를 가리킨다. getc(stdin) = getchar() // stdin = 키보드(표준 입력 파일)2. getchar() #define getchar() getc(stdin) 사용자가 입력한 문자를 버퍼에 저장해놓았다가 엔터(‘\\n’)를 누르면 엔터 이전의 문자들 가져옴 abc 입력 buffer : abc 저장 \\n buffer : abc 출력 buffer : \\n 남아있음 &amp;gt;&amp;gt; buffer 초기화 해줘야 함 buffer 초기화while (getchar() != &#39;\\n&#39;);// &#39;\\n&#39;를 만나기 전까지 버퍼에 저장 &amp;gt;&amp;gt; &#39;\\n&#39;만나면 while문장을 빠져나오므로 \\n가 버퍼에 입력되지 않음3. putc() 한 문자를 쓰는 함수 putc(문자, 문자를 입력할 파일); putc(int c, stdout) = putchar() // stdout = 화면(표준 출력 파일)4. putchar() #define putchar() putc(c, stdout)3. 고수준, 저수준 I/O 사용자가 직접 파일을 건드리느냐, 간접적으로 파일을 건드리느냐에 따라 고수준과 저수준으로 나뉘어 진다. 1. 고수준 파일 입출력 기본적으로 사용하는 파일 입출력 시스템에서 파일을 열 때 버퍼를 생성하고 그 버퍼에서 간접적으로 파일을 만짐 버퍼 단위로 읽고 쓰고 사용하기 쉬움- 주요 함수 파일 열기 : fopen(“파일이름”,모드); FILE *fp;fp = fopen(&quot;test.txt&quot;, &quot;r&quot;); // test.txt의 읽기모드(r)로 열기 모드 종류 모드 의미 파일존재여부 r 텍스트 파일 읽기 전용 미 존재시 에러 w 텍스트 파일 쓰기 전용 미 존재시 새로 생성 a 텍스트 파일 덧붙이기 전용 미 존재시 새로 생성 r+ 텍스트 파일 읽기+쓰기 미 존재시 에러 w+ 텍스트 파일 쓰기+읽기 미 존재시 새로 생성 데이터 쓰기 : fprintf(FILE* stream, “포맷”, 변수); = printf() fprintf(fp, &quot;%s&quot;, &quot;hello&quot;); // fp에 hello 입력 fprintf(stdout, “포맷”, 변수) = printf(“포맷”, 변수) 데이터 읽어오기 : fscanf(FILE* stream, “포맷”, 변수 주소); = scanf() fscanf(fp, &quot;%s&quot;, str); // fp의 배열 읽어오기 fscanf(stdin, “포맷”, 변수) = scanf(“포맷”, 변수) 텍스트 파일의 공백을 기준으로 읽는다. test.txt 내용 : abcdefg hijklmn opqrstu vwxyz fscanf(fp, “%s”, str); 결과 : abcdefg 읽은 데이터를 콘솔에 뿌리고 싶으면 printf() 사용[printf(“%s”, str);] 파일 닫기 : fclose(파일스트림); fclose(fp); 파일 사용 후 꼭 닫아줘야 한다. 2. 저수준 파일 입출력 파일 기술자의 번호에 의해 참조 0 : 표준 입력, stdin(키보드) 1 : 표준 출력, stdout(화면) 2 : 표준 오류, stderr(화면) 0 ~ 2의 번호는 프로세스 실행 시 기본적으로 할당 3번부터 파일을 처음 열면 시작되는 파일 기술자 바이트 단위로 읽고 쓰기 속도 빠름(파일 직접 접근)- 주요 함수 파일 열기 : open(“파일이름”,사용모드[, mode_t mode]) int fd;fd = open(&quot;test.txt&quot;,O_RDONLY); // test.txt를 읽기전용 모드로 열기 사용 모드 모드 의미 O_RDONLY 읽기 전용 O_WRONLY 쓰기 전용 O_RDWR 읽기 겸 쓰기 O_APPEND 기존 파일에 덧쓰기 mode 소유자, 그룹, 기타 사용자에게 읽기(r), 쓰기(w), 실행(x)의 권한을 8진수씩 나눠서 지정가능 소유자 그룹 기타 사용자 r|w|x r|w|x r|w|x 111111111(모든 권한 허용) : 0777(8진수로 표현) 111000000(소유자만 권한 허용) : 0700 파일 닫기 : close(파일 디스크립터); close(fd); 4. Buffer 데이터를 임시적으로 저장하는 공간 버퍼가 가득 차게되면 출력- Buffering 종류 full buffering : 일반 파일 &amp;gt;&amp;gt; 버퍼가 가득 차면 출력 line buffering : 키보드, 모니터 &amp;gt;&amp;gt; ‘\\n’기준 출력 printf(&quot;abc&quot;); // 버퍼에 저장만printf(&quot;def\\n&quot;); // abcdef 출력 ‘\\n’이 없어도 출력되는 예외의 경우 출력을 대기하고 있는 상태에서 입력 요구 printf(&quot;출력대기&quot;);scanf(&quot;%s&quot;,str); // 입력요구 fflush() 사용 : buffer 비우는 함수(buffer 출력!) exit() 사용 프로그램 종료 no buffering - 표준 error파일 &amp;gt;&amp;gt; 단순변수(데이터 하나밖에 저장 못함)이므로 바로바로 출력됨5. FILE &amp;lt; stdio.h &amp;gt;에 존재 파일을 제어할 때 사용// dev C++struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname;};typedef struct _iobuf FILE;5. 파일 새로 만들어 쓰고 읽기 예시#include &amp;lt;stdio.h&amp;gt;int main() { char read1[10], read2[10]; FILE *fp; // 파일 쓰기 fp = fopen(&quot;test.txt&quot;,&quot;w&quot;); // test.txt 없으면 새로 생성 fprintf(fp, &quot;%s&quot;, &quot;Hello, World&quot;); fclose(fp); // 쓰기 종료 // 파일 읽기 fp = fopen(&quot;test.txt&quot;,&quot;r&quot;); // test.txt 없으면 에러! fscanf(fp, &quot;%s %s&quot;, read1, read2); // test.txt 스캔(공백을 기준으로 배열 나뉨) printf(&quot;%s %s&quot;, read1, read2); // 스캔한 변수 콘솔 출력 fclose(fp); // 읽기 종료 return 0;}결과 : Hello, World" }, { "title": "C언어 공부 정리(9/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(9-2)/", "categories": "Language, C", "tags": "공부, C, 연습문제", "date": "2022-01-22 02:30:33 +0900", "snippet": "22/01/11단어리스트 입력받아 거꾸로 리스트 출력하기 단어리스트 struct node 생성 struct node { char *name; struct node *link; // struct node를 참조하는 포인터변수 link}; 단어 입력받기(함수 getname()) getchar()로 입력받기 getname()을 node에 추가(함수 addlist(), namecopy()) (node *)가 비어있으면 메모리 할당, node.name에 namecopy()로 단어 추가 node.link에 다음 단어 연결(재귀함수) ★역순환 리스트 생성(invert())★ 역순환 리스트 출력(listprint())#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;struct node { char *name; struct node *link;};int getname(char *);struct node *addlist(struct node *, char *); // addlist함수는 struct node 참조char *namecopy(char *);// invert함수 선언// malloc 사용 x, 주어진 연결 리스트에서 직접 link 변경시킬 것void listprint(struct node *);int main() { struct node *root; char name[80]; root = NULL; // NULL pointer while(getname(name) != EOF) // EOF : End Of File, `ctrl-z`누르면 실행 root = addlist(root, name); listprint(root); root = invert(root); printf(&quot;----- invert -----\\n&quot;); listprint(root); return 0;}int getname(char *pname) { int i = 0; char c; while(((c=getchar()) != &#39;\\n&#39;) &amp;amp;&amp;amp; c != EOF) *(pname + i++) = c; if (c == &#39;\\n&#39;) *(pname + i) = &#39;\\0&#39;; if (c == EOF) *pname = EOF; return *pname;}struct node *addlist(struct node *p, char *w) { if (p == NULL) { // null값인지 확인 후 p = (struct node *)malloc(sizeof(struct)); // 메모리 할당 &amp;gt;&amp;gt; 융통성은 있지만 속도는 떨어짐 p -&amp;gt; name = namecopy(w); p -&amp;gt; link = null; } else p -&amp;gt; link = addlist(p-&amp;gt;link, w); return p;}char *namecopy(char *s) { char *p; int i = 0; p = (char *)malloc(strlen(s) + 1); while((*(p+1) = *(s+i)) != &#39;\\0&#39;) i++; return p;}void listprint(struct node *p) { while(p != NULL) { printf(&quot;%s\\n&quot;, p -&amp;gt; name); p = p -&amp;gt; link; }}// invert 정의소스코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;struct node { char *name; struct node *link;};int getname(char *);struct node *addlist(struct node *, char *);char *namecopy(char *);// invert함수 선언struct node *invert(struct node *);void listprint(struct node *);int main() { struct node *root; char name[80]; root = NULL; // NULL pointer while(getname(name) != EOF) // EOF : End Of File, `ctrl-z`누르면 실행 root = addlist(root, name); listprint(root); root = invert(root); printf(&quot;----- invert -----\\n&quot;); listprint(root); return 0;}int getname(char *pname) { int i = 0; char c; while(((c=getchar()) != &#39;\\n&#39;) &amp;amp;&amp;amp; c != EOF) *(pname + i++) = c; if (c == &#39;\\n&#39;) *(pname + i) = &#39;\\0&#39;; if (c == EOF) *pname = EOF; return *pname;}struct node *addlist(struct node *p, char *w) { if (p == NULL) { p = (struct node *)malloc(sizeof(struct)); p -&amp;gt; name = namecopy(w); p -&amp;gt; link = null; } else p -&amp;gt; link = addlist(p-&amp;gt;link, w); return p;}char *namecopy(char *s) { char *p; int i = 0; p = (char *)malloc(strlen(s) + 1); while((*(p+1) = *(s+i)) != &#39;\\0&#39;) i++; return p;}void listprint(struct node *p) { while(p != NULL) { printf(&quot;%s\\n&quot;, p -&amp;gt; name); p = p -&amp;gt; link; }}// invert 정의struct node *invert(struct node *lead) { struct node *trail, *middle; middle = NULL; while(lead) { // lead가 NULL이 아닐 동안 trail = middle; middle = lead; lead = lead -&amp;gt; link; middle -&amp;gt; link = trail; } return middle;}실행 순서 applebananacandydangerEOF (입력) getname(name) char c = apple *p = c root = addlist(root, name) p값 *p-&amp;gt;name *p-&amp;gt;link *w   NULL NULL NULL apple   메모리할당 namecopy(w) NULL         apple NULL   getname(name) char c = banana *p = c root = addlist(root, name) p값 *p-&amp;gt;name *p-&amp;gt;link *w   not null apple NULL banana         addlist(p-&amp;gt;link,w)   NULL NULL NULL banana   메모리할당 namecopy(w) NULL         banana NULL   getname(name) char c = candy *p = c root = addlist(root, name) p값 *p-&amp;gt;name *p-&amp;gt;link *w   not null banana NULL candy         addlist(p-&amp;gt;link,w)   NULL NULL NULL candy   메모리할당 namecopy(w) NULL         candy NULL   getname(name) char c = danger *p = c root = addlist(root, name) p값 *p-&amp;gt;name *p-&amp;gt;link *w   not null candy NULL danger         addlist(p-&amp;gt;link,w)   NULL NULL NULL danger   메모리할당 namecopy(w) NULL         danger NULL   listprint(root); applebananacandydanger ----- invert ----- invert(root) invert 실행순서 No lead middle trail 1,2 apple|banana… NULL NULL 3   apple|banana…   4,5 banana… apple|NULL   No lead middle trail 1,2 banana…   apple|NULL 3   banana…   4,5 candy… banana|apple…   No lead middle trail 1,2 candy…   banana|apple… 3   candy…   4,5 danger… candy|banana…   No lead middle trail 1,2 danger|NULL   candy|banana… 3   danger|NULL   4,5 \\0 danger|candy…   listprint(root) dangercandybananaapple결과applebananacandydanger----- invert -----dangercandybananaapple" }, { "title": "C언어 공부 정리(9/10)-typedef, 비트 필드", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(9-1)/", "categories": "Language, C", "tags": "공부, C, structure", "date": "2022-01-19 23:44:50 +0900", "snippet": "22/01/111. typedef 모든 자료형의 별칭을 지정해 줄 수 있음 주로 struct에 많이 사용typedef int INT;typedef char C;int main() { INT i; // ≡ int i; C c; // ≡ char c;} struct 별칭 지정하기typedef struct People { int age; char name[80]; char addr[80];} P; struct 별칭 사용하기P p1; // struct People의 별칭 P의 변수 p1 생성typedef의 기준은 ‘이름’typedef char str[80]; // str : char[80]의 별칭str x; // → char x[80];typedef int *k; // k : int*의 별칭k x; // → int *x;2. 구조체의 비트 필드 struct 멤버를 비트단위로 저장 가능struct sct { unsigned int a : 3; // 정수형 자료형 : 비트 할당수 unsigned int b : 2; unsigned int c : 7;}s;ss.a = 7; // 111(3비트)ss.b = 1; // 1(1비트)ss.c = 63; // 111111(6비트)printf(&quot;s.a = %d, s.b = %d, s.c = %d\\n&quot;, s.a, s.b, s.c); 결과: s.a = 7, s.b = 1, s.c = 63 비트필드 설정 값 이상의 크기 사용 시 결과값 다르게 나옴struct sct { unsigned int a : 3; unsigned int b : 2; unsigned int c : 7;}s;s.a = 15; // 1111(4비트)s.b = 5; // 101(3비트)s.c = 255; // 1111 1111(8비트)printf(&quot;s.a = %d, s.b = %d, s.c = %d\\n&quot;, s.a, s.b, s.c); 컴파일러 : [Warning] large integer implicitly truncated to unsigned type (정수 오버플로우) 결과 : s.a = 7, s.b = 1, s.c = 127" }, { "title": "C언어 공부 정리(8/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(8-2)/", "categories": "Language, C", "tags": "공부, C, 연습문제", "date": "2022-01-19 21:16:09 +0900", "snippet": "22/01/10하나의 포인터 변수로 두 함수(strcmp, numcmp)를 다루는 함수(fcmp) 만들기 strcmp() : 문자열 비교하여 1, 0, -1로 리턴 strcmp(abc, abb) → 1 strcmp(123.2, 123.1) → 1 numcmp() : 숫자를 비교하여 1, 0, -1로 리턴 trcmp(123.2, 123.1) → -1 두 개의 문자열을 입력받아 두 문자열이 숫자열이면 numcmp()로, 문자가 하나라도 있으면 strcmp()로 함수 연결해 결과 출력#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;ctype.h&amp;gt; // 한 문자에 대한 라이브러리#include &amp;lt;string.h&amp;gt; // for strcmp()#include &amp;lt;stdlib.h&amp;gt; // for atof() → 문자열을 실수로 변경#define NUM 1#define CHARCT 2int numcmp(const char *, const char *); // numcmp 선언// void fcmp 선언int main() { char s[80], t[80]; // ptr은 두 개의 const char*를 인자로 가지고 있는 함수의 주소를 참조하는 변수 int (*ptr)(const char*, const char*); scanf(&quot;%s %s&quot;, s, t); fcmp(&amp;amp;ptr, s, t); // fcmp 콜 printf(&quot;%d\\n&quot;, ptr(s,t)); return 0;}// numcmp() 정의int numcmp(const char *ps, const char *pt) { float a, b; a = atof(ps); b = atof(pt); if(a&amp;gt;b) return 1; else if(a&amp;lt;b) return -1; else return 0;}// fcmp() 정의void fcmp() { int cond; cond = NUM; if(*ps == &#39;-&#39;) ps++; while (cond == NUM &amp;amp;&amp;amp; *ps != NULL) if(isdigit(*ps) || *ps == &#39;.&#39;) ps++; else cond = CHARCT; if(*pt == &#39;-&#39;) pt++; while (cond == NUM &amp;amp;&amp;amp; *pt != NULL) if(isdigit(*pt) || *pt == &#39;.&#39;) pt++; else cond = CHARCT; // ps, pt 모두 숫자열이면 numcmp 함수 연결 // 아니면 strcmp 함수 연결}소스코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;ctype.h&amp;gt; // 한 문자에 대한 라이브러리#include &amp;lt;string.h&amp;gt; // for strcmp()#include &amp;lt;stdlib.h&amp;gt; // for atof() → 문자열을 실수로 변경#define NUM 1#define CHARCT 2int numcmp(const char *, const char *); // numcmp 선언void fcmp(int(**)(const char *, const char *), char *, char *); // 1. fcmp 선언int main() { char s[80], t[80]; int (*ptr)(const char*, const char*); scanf(&quot;%s %s&quot;, s, t); fcmp(&amp;amp;ptr, s, t); // fcmp 콜 printf(&quot;%d\\n&quot;, ptr(s,t)); return 0;}// numcmp() 정의int numcmp(const char *ps, const char *pt) { float a, b; a = atof(ps); b = atof(pt); if(a&amp;gt;b) return 1; else if(a&amp;lt;b) return -1; else return 0;}// fcmp() 정의void fcmp(int (**p)(const char*, const char*), int *ps, int *pt) { int cond; cond = NUM; // NUM = 1, #define에 의한 설정 if(*ps == &#39;-&#39;) // 음수일 경우 ps 위치 변경 + 1 ps++; while (cond == NUM &amp;amp;&amp;amp; *ps != NULL) //cond가 1이고 *ps가 NULL이 아닐동안 roop if(isdigit(*ps) || *ps == &#39;.&#39;) // 2. isdigit(int) = 숫자를 판단하는 함수 ps++; else cond = CHARCT; // CHARCT = 2 if(*pt == &#39;-&#39;) pt++; while (cond == NUM &amp;amp;&amp;amp; *pt != NULL) if(isdigit(*pt) || *pt == &#39;.&#39;) pt++; else cond = CHARCT; // 3. ps, pt의 결과에 따른 함수 연결 if(cond == NUM) // numcmp 함수 연결 *p = numcmp; else // strcmp 함수 연결 *p = strcmp;} fcmp(&amp;amp;ptr, s, t) : 문자열 s, t를 입력받아 s, t의 배열이 숫자인 경우 numcmp(), 아닌 경우 strcmp()로 전달해줄 포인터변수 ptr 포인터변수를 매개로 사용했기에 이중포인터(**)로 포인터변수가 참조하는 주소를 참조 isdigit(int) : int가 숫자일 경우 1(T), 아닐 경우 0(F)을 return isdigit(int)가 T이거나 *ps가 ‘.’일 경우 ps += 1 아닐 경우 = 숫자가 아닌 경우, cond = 2 cond3 = 2가 되면 while이 돌아가지 않고 빠져나옴 ps, pt의 결과가 NUM(1)일 경우 포인터함수는 numcmp를 가리키고 ps, pt의 결과가 CHARCT(2)일 경우 포인터함수는 strcmp를 가리킴 int (*ptr)(const char*, const char*) : 같은 리턴, 요소 함수 포인터로 가리키기실행순서 scanf(“%s %s”, s, t) : s, t 문자열 받기 fcmp(&amp;amp;ptr, s, t) *ps, *pt의 첫 문자가 -(음수)면 ps, pt ++ while : 숫자일 경우 실행, 문자가 있으거나 ps, pt가 NULL이면 빠져나옴 숫자열이면 *p의 주소는 numcmp() 문자열이면 *p의 주소는 strcmp() " }, { "title": "C언어 공부 정리(8/10)-cmd-line, structure", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(8-1)/", "categories": "Language, C", "tags": "공부, C, command-line, structure", "date": "2022-01-16 18:22:10 +0900", "snippet": "22/01/101. main(int argc, char *argv[]) main에 사용될 수 있는 파라미터 cmd창에서 사용됨 argc : 함수 main에 전달되는 데이터의 개수 argv : 함수에 전달되는 실질적 데이터 데이터는 공백기준으로 나뉜다ex#include &amp;lt;stdio.h&amp;gt;int main(int argc, char *argv[]) { int i; for (i=0; i&amp;lt;argc; i++) printf(&quot;argv[%d]의 데이터는 %s입니다.\\n&quot;, i, argv[i]); printf(&quot;argc의 개수는 %d개 입니다.\\n&quot;, argc); return 0;}cmd 실행 cd 실행파일이 있는 경로 ex hello my name is ym ex : 실행파일 hello my name is ym : 공백을 기준으로 데이터 나눠짐 argv[0] : 실행파일2. structure(구조체) 사용자가 정의한 자료형의 집합체 → 구조체 - 구조체 정의 struct Personal { char name[80]; int age;}; struct 구조체_이름 { 자료형 이름; }; 엑셀의 hearder같은 모양 excel A B   1 name age « struct 2 홍길동 20   3 김철수 15   메모리상에 구조체의 자료형들은 아직 자리가 잡혀있지 않음(메모리 할당 x)- 구조체 변수 선언struct Personal ps; // ps = struct Personal- 구조체 정의와 동시에 변수 선언 struct Personal { // 구조체 정의 char name[80]; int age; } ps; // 구조체 변수 이름- 구조체 변수의 자료형 접근 변수.자료형이름ps.name; // struct Personal의 char name[80]에 접근- 구조체 자료형 초기화struct Personal psl = {&quot;홍길동&quot;, 20}; // struct Personal변수 psl에 값 초기화// orps = {&quot;홍길동&quot;, 20}; // 자료 순서대로 초기화됨// orps = {.name = &quot;김영희&quot;, .age = 15};- 구조체 변수 자료형 초기화// char[]strcpy(&quot;김철수&quot;, ps.name); // strcpy(붙여넣을 배열, 복사할 배열);// intps.age = 15;- 구조체 포인터struct Personal *ptr; // 변수명 : ptr, 자료형 크기 : struct Personalptr = &amp;amp;ps; // ps 주소를 참조ptr -&amp;gt; age = 30; // ps의 age 값에 30을 입력printf(&quot;%d\\n&quot;, ptr -&amp;gt;age);결과 : 30" }, { "title": "C언어 공부 정리(7/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(7-2)/", "categories": "Language, C, 연습문제", "tags": "공부, C", "date": "2022-01-16 15:55:53 +0900", "snippet": "22/01/07주어진 문자열에 다른 주어진 문자를 제거하고 역순화 시킨 문자열 만드는 함수 ex)abcabc b (입력) → caca (출력) 조건 함수명 : revsqueeze 포인터만 사용할 것(배열x) #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; // for strlen()#include &amp;lt;stdlib.h&amp;gt; // for malloc()// 함수 선언int main() { // 변수 선언 while ((s[i++] = getchar()) != &#39;\\n&#39;); s[i--] = &#39;\\0&#39;; c = getchar(); result = revsqueeze(s, c); printf(&quot;%s\\n&quot;, result); return 0;}// 함수 정의{ // 변수 선언 len = strlen(ps); temp = (char *)malloc(len + 1); // 결과 문자열 저장 공간 생성 // 알고리즘 return temp;}소스 코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;char *revsqueeze(char*, char); // 1. 함수 선언int main() { int i=0; char s[80], c, *result; while ((s[i++] = getchar()) != &#39;\\n&#39;); s[i--] = &#39;\\0&#39;; c = getchar(); result = revsqueeze(s, c); // 2. 포인터 변수 = 포인터 함수 printf(&quot;%s\\n&quot;, result); return 0;}char *revsqueeze(char *ps, char c) { int i, j=0, len; char *temp; len = strlen(ps); // 포인터의 길이만큼 len 설정 temp = (char *)malloc(len + 1); // 포인터 길이만큼 메모리 확보 ps = ps + len -1; // 3. 포인터의 위치를 포인터의 끝으로 변경(문제 조건을 위한 설정) for(i=0; i&amp;lt;len; i++) { // len(포인터의 길이)만큼 for문 실행 if (*ps != c) // 4. 포인터가 가리키는 값이 c와 같지 않으면 *(temp + j++) = *ps--; // temp에 c 추가 후 포인터 위치 변화 else ps--; // 포인터와 c가 같으면 건너뛰기 } *(temp - j) = &#39;\\0&#39;; return temp;} main()의 배열(s)을 call by reference로 사용하기 위해 * 사용 포인터 함수 결과를 저장하기 위해 포인터 변수 사용 ps = ps[0] &amp;gt;&amp;gt; ps[0]을 ps 마지막으로 위치이동 = ps + len &amp;gt;&amp;gt; ps[len] &amp;gt;&amp;gt; ps의 마지막 위치 = len -1 &amp;gt;&amp;gt; ps + (len - 1) ex) s = “hello” s[0] = h, s[1] = e, s[2] = l, s[3] = l, s[4] = o strlen(s) = 5 s[strlen(s)] = s[5] = ‘\\0’(NULL) s[strlen(s) - 1] = s[4] = ‘o’ *ps != c *ps = *ps가 참조하는 값 ex) s[] = {1,2}; *ps = s; *ps ≡ *(ps + 0) ≡ *ps[0] ≡ 1 != 아니다! int n = 3;if (n != 2) printf(&quot;3이 아니다!&quot;);else printf(&quot;3이다!&quot;); 결과 : 3이다! if ( *ps != c ) : ps가 참조하는 값이 c가 아니라면실행 순서 abcab a (입력) s = {‘a’, ‘c’, ‘c’, ‘a’, ‘b’} c = ‘a’ revesqueeze(s, c) len = strlen(s) = 5 temp = (char *)malloc(len + 1) &amp;gt;&amp;gt; temp에 6바이트 메모리 확보 ps = ps[4] for j = 0, 1, 2, 3, 4 j값 i값 *ps값 *ps != c 결과 *(temp+i)값   0 0 b T(b!=a)         0   b       1 a     1 1 a F(a!=a)           c     2 1 c T(c!=a)         1   c       2 c     3 2 c T(c!=a)         2   c       3 a     4 3 a F(a!=a)           NULL     5           *(temp + 3) = ‘\\0’ *temp → {‘b’, ‘c’, ‘c’} return temp main()   result = {‘b’, ‘c’, ‘c’} printf(“%s\\n”, result);결과 bcc" }, { "title": "C언어 공부 정리(7/10)-포인터", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(7-1)/", "categories": "Language, C", "tags": "공부, C, 포인터", "date": "2022-01-15 12:05:55 +0900", "snippet": "22/01/071. 포인터 연산1. 단순 연산int a[] = {0, 1, 2, 3, 4}; // 선언&amp;amp;초기화 = 데이터 크기 자동으로 지정됨.int i, *p;// 1.for(p=&amp;amp;a[0], i=1; i&amp;lt;=5; i++) printf(&quot;%d\\n&quot;, p[i]);// 2.for(p=a, i=0; p+i&amp;lt;=a+4; p++,i++) printf(&quot;%d\\n&quot;, *(p+i));// 3.for(p=a+4, i=0; i&amp;lt;=4; i++) printf(&quot;%d\\n&quot;,p[-i]); p = &amp;amp;a[0] → p+0의 값 = a[0]의 주소 → p = 0 value 0 1 2 3 4 a_indx 0 1 2 3 4 p_indx p+0(≡p[0]) p+1(≡p[1]) p+2(≡p[2]) p+3(≡p[3]) p+4(≡p[4]) i 값 1 2 3 4 5 p[i] 1 2 3 4 ?? 결과 1 2 3 4 ?? ※포인터는 메모리 전체를 배열로 보기 때문에 선언된 배열의 값이 없더라도 다음 메모리에 있는 무언가를 불러올 수 있음 p = a → a = a[0] → p+0의 값 = a[0]의 주소 → p = 0 value 0 1 2 3 4 a_indx 0 1 2 3 4 p_indx p+0 p+1 p+2 p+3 p+4 p + i &amp;lt; a + 4 → p[i] &amp;lt; a[4] (a[4] = 4) : p[i]가 a[4] 즉, 4보다 작거나 같다면 for문 실행 *(p+i) 0 2 4 6 8 p++ 0 1 2 3 4 i++ 0 1 2 3 4 *(p+i) &amp;lt;= 4인 경우 : *(p+0), *(p+2), *(p+4)     ※ *(p+1) = p[1] 결과 0 2 4 p = a + 4 value 0 1 2 3 4 a_indx 0 1 2 3 4 p_indx p-4 p-3 p-2 p-1 p+0 i 0 1 2 3 4 p[-i] p[0] p[-1] p[-2] p[-3] p[-4] value 4 3 2 1 0 결과 4 3 2 1 0 2. 타입 연산 포인터는 같은 타입만 참조할 수 있다. 불가능 int x = 1;float y = 1.1;float *p = y; // 가능p = x; // error! int 메모리 : 4bit float 메모리 : 8bit 포인터는 메모리의 주소를 참조.(int를 가리키면 4byte 참조, float를 가리키면 8byte 참조) 메모리 크기 차이 때문에 다른 타입을 연결할 수 없음 int a[] = {0,1,2,3,4};int *p[] = {a, a+1, a+2, a+3, a+4};int **pp = p;// 1.pp++;printf(&quot;%d %d %d\\n&quot;, pp-p, *pp-a, **pp);// 2.*pp++;printf(&quot;%d %d %d\\n&quot;, pp-p, *pp-a, **pp);// 3.*++pp;printf(&quot;%d %d %d\\n&quot;, pp-p, *pp-a, **pp); 변수의 관계 실행결과 포인터 연산자는 8byte의 크기를 가지고 있었음 pp++ &amp;gt;&amp;gt; p + 1 pp-p = (p + 1) - p = (메모리주소)6664 - 6656 = 8(8x1) &amp;gt;&amp;gt; 1(포인터의 차를 출력) *pp-a = *(p + 1) - a = 1 - 0 = 1(둘 다 값을 가리킴으로 값의 계산) **pp = 1(주소를 두 번 따라가면 값이 나옴) *pp++ &amp;gt;&amp;gt; *(pp++) &amp;gt;&amp;gt; *(p + 2) &amp;gt;&amp;gt; 2 pp-p = (p + 2) - p = 6672 - 6656 = 16(8x2) &amp;gt;&amp;gt; 2 *pp-a = *(p + 2) - a = 2 - 0 = 2 **pp = 2 *++pp &amp;gt;&amp;gt; *(++pp) &amp;gt;&amp;gt; *(p + 3) &amp;gt;&amp;gt; 3 pp-p = (p + 3) - p = 6680 - 6656 = 24(8x3) &amp;gt; 3 *pp-a = *(p + 3) - a = 3 - 0 &amp;gt;&amp;gt; 3 **pp = 3 2. 다차원 배열1. 모양int a[3][3] { {1,2,3}, {4,5,6}, {7,8,9}};int *pa[3] = {a[0],a[1],a[2]};int *p = a[0]; 변수의 관계 주소 출력 pa : pa 자체 주소 같은 주소 pa[0] pa[0]+0 a[0]+0 p+0 p 값 출력(모두 같은 값) pa[0][0] *(pa[0]+0) a[0][0] *(a[0]+0) *(p+1) *p 2.char *c[] = {&quot;ENTER&quot;, &quot;NEW&quot;, &quot;POINT&quot;, &quot;FIRST&quot;};char **cp[] = {c+3, c+2, c+1, c+0};char ***cpp = cp;main(){ printf(&quot;%s&quot;, **++cpp); // 1. printf(&quot;%s &quot;, *--*++cpp + 3); // 2. printf(&quot;%s&quot;, *cpp[-2] + 3); //3. printf(&quot;%s\\n&quot;, cpp[-1][-1] + 1); // 4.} 변수 관계 **(++cpp) &amp;gt;&amp;gt; *(cp[1]) &amp;gt;&amp;gt; c+2 &amp;gt;&amp;gt; POINT *--*(++cpp)+3 &amp;gt;&amp;gt; *--*(cp[2])+3 &amp;gt;&amp;gt; *(–(c+1))+3 &amp;gt;&amp;gt; *(c+0)+3 &amp;gt;&amp;gt; ENTER + 3 &amp;gt;&amp;gt; ER (+3 : 배열의 4번째 자리부터 사용) *cpp[-2] + 3 &amp;gt;&amp;gt; *(c+3)+3 &amp;gt;&amp;gt; FIRST + 3 &amp;gt;&amp;gt; ST cpp[-1][-1] + 1 &amp;gt;&amp;gt; (cpp[-1])[-1]+1 &amp;gt;&amp;gt; (c+2)[-1]+1 &amp;gt;&amp;gt; (c+1)+1 &amp;gt;&amp;gt; NEW + 1 &amp;gt;&amp;gt; EW결과 : POINTER STEW3. 함수 호출 방법1. call by value 값을 복사해서 사용 void swap(int, int);int main() { int a = 10; int b = 20; swap(a, b); printf(&quot;in main : a = %d, b = %d\\n&quot;, a, b);}void swap(int x, int y) { // 값 복사해서 불러오기 int temp; temp = x; // temp : 10 x = y; // x : 20 y = temp; // y : 10 printf(&quot;in func : x = %d, y = %d\\n&quot;, x, y);} 결과 in func : x = 20, y = 10 in main : a = 10, b = 20 함수 내부에서는 x, y 값이 바뀌었지만, main으로 넘겨주지 못함 함수는 사용이 끝나면 모든 정보가 소멸됨! x, y또한 사라지기 때문에 main의 a, b의 값은 변함 없음 2. call by reference 값을 참조해서 사용 void swap(int*, int*);int main() { int a = 10; int b = 20; swap(&amp;amp;a, &amp;amp;b); printf(&quot;in main : a = %d, b = %d\\n&quot;, a, b);}void swap(int *x, int *y) { // 값의 주소 참조 int temp; temp = *x; // temp : 10 *x = *y; // *x : 20 *y = temp; // *y : 10 printf(&quot;in func : *x = %d, *y = %d\\n&quot;, *x, *y);} 결과 in func : x = 20, y = 10 in main : a = 20, b = 10 함수에서 주소를 이용해 값을 변경하는 것으로, 원본을 직접 바꿀 수 있음4. void pointer(범용 포인터) 선어 방법 void *p; 어떤 타입을 참조할 지 정해지지 않은 포인터 → 어느 타입의 포인터든 다 사용할 수 있음 어느 타입의 포인터던 범용 포인터 참조 가능 자료형의 크기가 정해져 있지 않으므로 역참조 불가```cint *ip;p = ip; // void 포인터가 int타입 포인터 참조ip = p; // int 포인터가 void포인터 참조*p = ‘a’; // void 포인터는 데이터 타입이 정해져 있지 않기 때문에 역참조 불가```" }, { "title": "C언어 공부 정리(6/10)-포인터 맛보기", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(6-3)/", "categories": "Language, C", "tags": "공부, C, 포인터", "date": "2022-01-10 01:02:20 +0900", "snippet": "22/01/061. 포인터 연산자&amp;amp;(주소 연산자) 단항연산자 변수의 주소값을 리턴 ex) int x = 3;printf(&quot;%d, &quot;, &amp;amp;x); // 변수의 주소 출력printf(&quot;%d&quot;, x); // 변수의 값 출력 결과 : 주소값, 3※ 배열의 이름은 주소값을 나타낸다!int arr[5] = {1,2,3,4,5};printf(&quot;%d&quot;, arr);결과 : 주소값&amp;amp;단순변수 = 변수명*(참조 연산자) 포인터 주소를 가리키고 있다. 사용법 // 단순변수int x = 1;int *p; // 포인터 선언p = &amp;amp;x; // x의 주소를 가리킴 // 배열int y[5] = {1,2,3,4,5};int *q = y; // 배열명 자체가 주소이기 때문에 &#39;&amp;amp;&#39;연산자 없이 사용 가능 2. 포인터와 배열 포인터가 배열을 가리킬 시 배열 전체를 가리킴 배열 내부의 값(index) 가리키기 q[0] = q+0 = y+0 = y[0] = 1 q[3] = q+3 = y+3 = y[3] = 4포인터 index, 배열 indexint y[10];printf(&quot;%d&quot;, y[11]); // error!int *p = y;printf(&quot;%d&quot;, p[11]); // ok 배열의 index 초기화시 배열의 크기가 정해짐 크기는 변하지 않음 배열 크기보다 큰 index 지정시 오류발생 포인터의 index 포인터는 메모리 전체를 배열로 봄 포인터가 가리키는 배열의 index를 초과하면 그 다음 주소를 가리킨다. 포인터의 배열 설정int a[10];int *q;q = &amp;amp;a[3]; // q의 index 설정 배열 a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7] a[8] a[9] 포인터 q-3 q-2 q-1 q q+1 q+2 q+3 q+4 q+5 q+6 포인터 index 설정에 따라 배열의 index와는 다를 수 있다.3. 형의 합성 기본 int *p; int **p; int *p[3]; int (*p)[3]; int *p[3][4]; int (*p)[3][4]; 우선 증가 나선 법칙 ‘변수명 &amp;gt;&amp;gt; 오른쪽 &amp;gt;&amp;gt; 왼쪽 &amp;gt;&amp;gt; 오른쪽’ 순으로 해석하는 법칙 만약 괄호()가 있다면 괄호를 먼저 본다. int *func(void); int (*p)(void); int (*func(void))[3]; int (*p[3])(void); 4. 함수의 배열 값 리턴 단순변수인 경우 함수에서 리턴할 때 값이 그대로 리턴됨 배열인 경우 함수에서 리턴할 때 값이 들어오지 않음 함수가 끝나면 함수안의 모든 자료들이 사라지기 때문 배열명은 값이 아닌 주소 malloc(크기) : 메모리 공간을 확보하는 함수 함수의 자료를 메모리에 저장해 리턴될 수 있게 해준다. 사용법 *변수 = (데이터타입 *)malloc(크기); 예시#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; // for malloc()char *func();int main() { char *p; p = func();}char *func() { char *x; x = (char *)malloc(5); // 메모리 5개 할당 return x;}5. 같은 리턴, 요소 함수 포인터로 가리키기float add(float, float);float mul(float, float);float sub(float, float);float mol(float, float);int main() { float (*p)(float, float); // float func(float, float) 함수 가리킴 p = add; // add함수를 가리킴}" }, { "title": "C언어 공부 정리(6/10)-매크로", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(6-2)/", "categories": "Language, C", "tags": "공부, C, 매크로", "date": "2022-01-09 21:14:44 +0900", "snippet": "22/01/061. 전처리기 컴파일러에게 특성을 알려주는 키워드 #include : 어떤 파일을 사용할 것인가? #include &amp;lt;stdio.h&amp;gt; : built in function #include “파일명” : 사용자 정의 함수 #define : 매크로 키워드 etc..2. 프로그램 실행 순서int main() { func1(); func2();} 프로그램이 실행되면 stack에 함수가 호출되고 사용이 완료된 함수는 소멸(stack에서 제거) main()은 프로그램의 실행과 끝. main이 종료되면 프로그램도 종료3. 매크로 함수는 호출해서 사용하기 때문에 코드는 짧지만 반복되는 횟수가 많아질수록 속도가 떨어질 수 있다. 매크로는 컴파일시 매크로를 사용하는 부분에 내용이 치환되어 순서대로 실행되기 때문에 속도는 빨라진다. 대신 메모리는 길어진다.- 사용법 매크로의 이름과 요소의 개수 중요 #define name(param1, param2) statement 실행문은 한줄만 번역 여러문장 번역 시 \\로 다음 줄까지 번역 #define name(param) statement1 \\ statement2 // 위아래 둘다 번역 - 사용시 주의점 치환된 매크로의 코드는 순서대로 실행되기 때문에 우선순위를 고려해야 한다. ex) 퍼센트 계산 매크로#define percent(part, total) (part / total * 100)int main() { printf(&quot;%f%%&quot;, percent(30 + 30, 300));} 치환된 후 코드 printf(&quot;%f%%&quot;, 30 + 30 / 300 * 100); 계산 순서 : 30 + 0.1 * 100 &amp;gt;&amp;gt; 30 + 10 &amp;gt;&amp;gt; 40 결과 : 40% 정확한 결과를 만들기 위해 매크로 수정 #define percent(part, total) ((part) / (total) * 100) // part, total 모두 값을 모르므로 ()로 한 묶음임을 표시int main() { printf(&quot;%f%%&quot;, percent(30 + 30, 300));} 치환된 후 코드 printf(&quot;%f%%&quot;, (30 + 30) / (300) * 100); 계산 순서 : 60 / 300 * 100 &amp;gt;&amp;gt; 0.2 * 100 &amp;gt;&amp;gt; 20 결과 : 20% - 같은 이름, 다른 인자 개수 알맞은 매크로 사용가능 ex)#define sum(x) ((x) + 1)#define sum(x, y) ((x) + (y))int main() { printf(&quot;%d, &quot;, sum(10)); printf(&quot;%d&quot;, sum(10, 20));}결과 : 11, 20- 같은 이름, 같은 인자 개수 마지막 매크로만 실행 ex)#define sum(x) ((x) + 1)#define sum(n) ((n) + (n))int main() { printf(&quot;%d, &quot;, sum(10)); printf(&quot;%d&quot;, sum(10));}결과 : 20, 20- 매크로 안의 매크로#define year(one) (day(hour)/12)#define day(mins) ((min)/24)int main() { printf(&quot;%d&quot;, year(day(576)));} 함수일 경우 실행 순서 year(day(576)) &amp;gt;&amp;gt; year(576/24) &amp;gt;&amp;gt; year(24) &amp;gt;&amp;gt; year(24/12) &amp;gt;&amp;gt; 12 결과 : 12 매크로는 순서대로 진행된다. 실행 순서 year(day(576)) &amp;gt;&amp;gt; year(one) &amp;gt;&amp;gt; day(hour)/12 day(hour)/12 &amp;gt;&amp;gt; day(mins)/12 &amp;gt;&amp;gt; 576/24/12 결과 : 12 + 매크로 사용시 결과가 다르게 나올 수 있음 긴 식을 세울 경우 너무 복잡해지기때문에 간단한 식에 사용하는것이 적합" }, { "title": "C언어 공부 정리(6/10)-재귀함수", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(6-1)/", "categories": "Language, C", "tags": "공부, C, 재귀함수", "date": "2022-01-09 02:48:22 +0900", "snippet": "22/01/061. 재귀함수란 ‘나’를 다시 부르는 함수 ex) void rec();int main() { rec(); return 0;}void rec () { printf(&quot;rec&quot;); rec(); // 재귀함수 &#39;나&#39; 안에 &#39;나&#39;를 부름} 결과 : recrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrecrec…… 끝없이 호출됨 에러! Stack Overflow!2. 재귀함수 조건+(예시 factorial!) 재귀함수 사용 시 조건부를 사용해서 빠져나올 수 있게 한다.- 팩토리얼 재귀함수! 팩토리얼의 모양#include &amp;lt;stdio.h&amp;gt;int factorial(int);int main() { int num; scanf(&quot;%d&quot;, &amp;amp;num); num = factorial(num); printf(&quot;%d&quot;, num); return 0;}int factorial(int num) { if(num == 0) // 재귀함수 빠져나올 수 있는 조건 return 1; return num * factorial(num - 1);}num = 5실행 순서 결과 : 1203. 그림그리며 생각하기 재귀함수를 짤 때, 어떤 식으로 코드가 움직이는지 직접 그려가면서 생각하는 것이 좋다.- 1 ~ n까지 수의 합 함수 만들기 그림 코드 #include &amp;lt;stdio.h&amp;gt;int sum(int);int main() { int num; num = sum(10); printf(&quot;%d&quot;, num); return 0;}int sum(int num) { if(num == 1) return 1; return num + sum(num-1);}결과 : 55" }, { "title": "C언어 공부 정리(5/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(5)/", "categories": "Language, C", "tags": "공부, C, 연습문제", "date": "2022-01-08 21:55:35 +0900", "snippet": "22/01/051. 주어진 두 문자열의 사전상 순서를 비교해주는 함수 만들기 &amp;lt;string.h&amp;gt;에 있는 함수 strcmp(문자열, 문자열); 만들기 사용 예시 strcmp(&quot;abc&quot;, &quot;abc&quot;); // 문자열이 같을 경우 return 0;strcmp(&quot;abbd&quot;, &quot;fbc&quot;); // a &amp;lt; f 앞의 문자열이 뒤의 문자열보다 작을 경우 return -1;strcmp(&quot;azc&quot;, &quot;aif&quot;); // z &amp;gt; i 앞의 문자열이 뒤의 문자열보다 클 경우 return 1;strcmp(&quot;abc&quot;, &quot;abcd&quot;); // 마지막 문자: &#39;\\0&#39;, &#39;d&#39; ∴ &quot;abc&quot; &amp;lt; &quot;abcd&quot; return -1; 조건 함수명 : mystrcmp #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; // strlen()// 함수 선언int main() { // 변수 선언 while ((s[i++] = getchar()) != &#39;\\n&#39;); s[i--] = &#39;\\0&#39;; while ((t[j++] = getchar()) != &#39;\\n&#39;); t[j--] = &#39;\\0&#39;; result = mystrcmp(s,t); return 0;}// 함수 정의소스 코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int mystrcmp(char[], char[]);int main() { // 변수 선언 char s, t; int i = 0, j = 0, result; while ((s[i++] = getchar()) != &#39;\\n&#39;); // abc 입력 시, s = &quot;abc&quot;; s[i--] = &#39;\\0&#39;; // &quot;abc\\0&quot; &amp;gt;&amp;gt; 문자열의 끝 while ((t[j++] = getchar()) != &#39;\\n&#39;); t[j--] = &#39;\\0&#39;; result = mystrcmp(s,t); return 0;}// 함수 정의int mystrcmp(char s[], char t[]) { int i, len; len = strlen(s) &amp;gt; strlen(t) ? strlen(t) : strlen(s); // 1. 삼항연산 // 2. 문자배열의 값 비교 for (i=0; i&amp;lt;len; i++) { if (s[i] &amp;gt; t[i]) return 1; else if (s[i] &amp;lt; t[i]) { return -1; } } // 3. 문자 길이 비교 if (strlen(s) &amp;gt; strlen(t)) return 1; else if (strlen(s) &amp;lt; strlen(t) return -1; else return 0;} 삼항연산 → 조건 ? 참 : 거짓; 조건이 참일 경우 ‘참’ 실행, 거짓일 경우 ‘거짓’ 실행 문자배열의 값 비교 ‘문자열 s’와 ‘문자열 t’ 중 짧은 길이의 문자열을 len의 값으로 설정 앞문자열(s)의 i번째 문자가 뒷문자열(t)의 i번째 문자보다 크다면 1 (s=’a’‘b’‘c’ &amp;gt; a는 0번째) 앞문자열의 i번째 문자가 뒷문자열의 i번째 문자보다 작다면 -1 그렇지 않다면(앞문자s[i]와 뒷문자t[i]가 같다면) 실행되는 것 없음 for문 결과 리턴되는 것이 없다면 종료 for문 종료 후 문자열의 길이 비교 ‘abcd’(길이4), ‘abc’(길이3) 문자 비교 결과 ‘abc’가 같으므로 for문 종료 ‘abcd’, ‘abc’의 길이 비교 후 리턴 실행순서 abcc (입력) -&amp;gt; s배열에 저장 abb (입력) -&amp;gt; t배열이 저장 mystrcmp(s,t) 실행 len = strlen(t) = 3 for문 : 0 to 2 즉, 3회 실행 i = 0 &amp;gt;&amp;gt; s[0] = &#39;a&#39;, t[0] = &#39;a&#39; i = 1 &amp;gt;&amp;gt; s[1] = &#39;b&#39;, t[1] = &#39;b&#39; i = 2 &amp;gt;&amp;gt; s[2] = &#39;c&#39;, t[2] = &#39;b&#39; // s[2] &amp;gt; t[2] return 1; printf 실행 결과 : 12. 문자열을 실수로 만들어주는 함수 만들기 &amp;lt;stdlib.h&amp;gt;에 있는 함수 atof(문자열); 만들기 사용 예시 atof(&quot;135.553&quot;); // 135.55300// ※실수는 정확도가 떨어지기 때문에 완벽하게 135.553이 안 나올 수 있음 조건 함수명 : myatof 힌트 소수점을 기준으로 변수1, 변수2에 저장 변수1, 2의 합을 리턴 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; // strlen()// 함수 선언int main() { float num; char str[80]; scanf(&quot;%s&quot;, str); num = myatof(str); printf(&quot;%f\\n&quot;, num); return 0;}// 함수 정의{ // 변수 선언 if (str[0] == &#39;-&#39;) { sign = -1; i = 1; } // 소수점 이상 // 소수점 이하 // 소수점 이하 한번 더 나누기 // 결과 저장 return num;}소스 코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int myatof(char[]);int main() { float num; char str[80]; scanf(&quot;%s&quot;, str); num = myatof(str); printf(&quot;%f\\n&quot;, num); return 0;}int myatof(char str[]) { int i=0, sign=1; // sign : 부호(+,-)를 위한 변수 float num, num1=0.0, num2=0.0; // 실수 초기화값은 .0 붙여주는 것이 좋다고.. if (str[0] == &#39;-&#39;) { // 1. 음수일 경우 sign = -1; // 부호는 &#39;-&#39; i = 1; // for문 시작 위치 } // 2. 소수점 이상 for (; str[i] !=&#39;.&#39;; i++) num1 = num1 * 10 + str[i] - &#39;0&#39;; // 3. 소수점 이하 for (i=strlen(str); i&amp;gt;0; i--) num2 = num2 * 0.1 + str[i] - &#39;0&#39;; // 4. 소수점 이하 한번 더 나누기 num2 *= 0.1; // 5. 결과 저장 num = sign * (num1 + num2); return num;} 부호에 따른 문자열 저장 모양 양수 : index 0부터 숫자 시작 음수 : index 1부터 숫자 시작 소수점 이상 for문 초기화값 : 이미 설정되어 있으면 건너뛸 수 있음 문자열[str]의 ‘.’을 만나기 전까지 for문 실행 ‘문자’를 숫자로 바꾸기 위해 ‘숫자형 문자’(ascii code) - ‘0’(ascii code) ‘문자’와 ‘숫자’간의 형변환은 자유로움 ‘1’ : ascii code 49 ‘0’ : ascii code 48 ‘1’ - ‘0’ = 1 16진법을 10진법으로 바꾸는 문제 응용 123 &amp;gt;&amp;gt; 0 * 10 + 1 &amp;gt;&amp;gt; 1 &amp;gt;&amp;gt; 1 * 10 + 2 &amp;gt;&amp;gt; 12 &amp;gt;&amp;gt; 12 * 10 + 3 &amp;gt;&amp;gt; 123 소수점 이하 문자열의 마지막 index에서부터 거꾸로 for문 시작 0.123 : for문의 i값 &amp;gt;&amp;gt; 3 , 2 , 1 0.123 &amp;gt;&amp;gt; 0 * 0.1 + 3 &amp;gt;&amp;gt; 3 &amp;gt;&amp;gt; 3 * 0.1 + 2 &amp;gt;&amp;gt; 2.3 &amp;gt;&amp;gt; 2.3 * 0.1 + 1 &amp;gt;&amp;gt; 1.23 소수점 이하 결과 수정 소수점 이하의 결과(1.23) = 실제 숫자(0.123) * 10 결과값(1.23) * 0.1 = 실제 숫자(0.123) 결과 저장 양수인 경우 sign : 1 sign * (num1 + num2) = num1 + num2 음수인 경우 sign : -1 sign * (num1 + num2) = - ( num1 + num2) 실행 순서 123.456 (입력) myatof(num) 실행 sign = 1, i = 0 소수점 이상 num1 = 0 * 10 + 1 &amp;gt;&amp;gt; 1 * 10 + 2 &amp;gt;&amp;gt; 12 * 10 + 3 &amp;gt;&amp;gt; 123 소수점 이하 num2 = 0 * 0.1 + 6 &amp;gt;&amp;gt; 6 * 0.1 + 5 &amp;gt;&amp;gt; 5.6 * 0.1 + 4 &amp;gt;&amp;gt; 4.56 소수점 이하 재계산 num2 = 4.56 * 0.1 &amp;gt;&amp;gt; 0.456 결과 저장 num = 1 * ( 123 + 0.456 ) printf 실행결과 : 123.456000" }, { "title": "C언어 공부 정리(4/10)-변수", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(4-3)/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-08 01:05:00 +0900", "snippet": "22/01/041. 외부변수 함수 외부에 선언 프로그램이 끝날 때 까지 사라지지 않음.- 외부변수 종류1. 전역 변수 어디서나 어느 파일에서나 사용 가능 사용법 int won; // 미초기화시 값 : &#39;\\0&#39;, 초기화는 한번만int main() {} extern 다른 파일 전역변수 사용법 extern int another; // 값 바꾸기 불가. 변수를 불러오기만 하는 것 int main() {} 함수 또는 블록 내에서 전역변수 사용법 int won; // 함수 위에 선언되어 있어야 한다. int main() { extern int won; // 값 바꾸기 불가. } 2. 정적 외부 변수 초기화를 한 번 하면 바뀌지 않음 상수(const int MAX = 1000;)처럼 사용됨 같은 파일 내에서만 사용 가능 사용법 static int day; // 미초기화시 값 : &#39;\\0&#39;, 초기화는 한번만int main() {} 2. 내부변수 함수 또는 블록 내부에 선언 변수가 선언된 블록이 실행될 때만 사용- 내부변수 종류1. 지역 변수(자동 변수) main, function내부에서 선언했던 변수 원래는 auto int x;이나, auto는 생략하고 int x;로 선언된다. 사용법 int main() { int country; // 미초기화시 값 : 불명, 초기화는 수시로 가능} 2. 정적 내부 변수 정적 외부 변수가 함수/블록 내부에 선언 사용이 끝난 후 사라지는 지역 변수와는 다르게 프로그램이 끝날 때 까지 사라지지 않음. 변수가 사라지지는 않지만 속한 블록이 실행되지 않는 한 사용 불가 사용법 int main() { static int var; // 미초기화시 값 : &#39;\\0&#39;, 초기화는 한번만} 3. 레지스터 변수 레지스터에 저장되는 변수 속도가 아주 빠르다(단기간에 여러번 사용할 때 유용) 변수가 정의된 블록이 끝나면 사라짐 사용법 register int x; // 미초기화시 값 : 불명, 초기화는 수시로 가능 3. 메모리 구조 프로그램이 실행될 때 마다 생성1. 정적 영역 프로그램이 시작될 때 할당됨 전역변수, 정적변수(static),함수, 상수 할당 초기화값 : 02. 힙(Heap) 영역 컴파일될 때 크기, 주소가 모두 결정3. 스택(Stack) 영역 지역변수, 매개변수 할당 함수 호출이 완료되면 사라짐 → 지역변수가 속한 곳이 종료되면 수명이 끝나는 이유 컴파일 시 주소 저장, 실행(run)될 때 크기 확정4. 임시 변수 임시적으로 사용하고 끝나는 변수 예시) x, y의 값을 서로 변경하기(x=10, y=20 → x=20, y=10) int x = 10; int y = 20; 임시변수 미사용 x = y; // x = 10, y = 10; y = x; // y = 10, x = 10; 결과: x = 10, y = 10 임시변수 사용 int temp; // 임시변수 y = temp; // x = 10, y = 20, temp = 20; y = x; // x = 10, y = 10, temp = 20; x = temp; // x = 20, y = 10; temp는 필요 x 결과 : x = 20, y = 10 5. Block structure C에서는 변수가 선언될 수 있는 공간이 따로 있다. 원칙적으로는 다른 곳에 새로운 변수 선언 시 에러! 새로운 변수를 선언해야 할 경우 사용 ex) int x; // var1 int main() { int x = 10; // var2 x++; // var2++ &amp;gt;&amp;gt; var2 = 11; { int x = 20; // var3 x--; // var3-- &amp;gt;&amp;gt; var3 = 19; { extern int x; // for var1 x++; // var1 = 1; (전역변수 미초기화값: 0) } x--; // var3-- &amp;gt;&amp;gt; var3 = 18; } x++; // var2++ &amp;gt;&amp;gt; var2 = 12;} 주의 : 블록 내부에 변수가 없다면 바깥 변수를 확인 scope read = LGB(Local → Global → Built in function) // 변수 확인 순서 지역 변수 없음 → 전역변수 확인 → 전역변수 없음 → 전처리기 함수(라이브러리) 확인```cchar print[10] = “print\\n”; // 1// 사용된 변수 = 1 int main() { char print[5] = “hello”; // 2 // 사용된 변수 = 2 { print = “bye\\n”; // 3 // 사용된 변수 = 2 { extern char print = “sleep”; // extern : 바로 전역변수로 올라가! // 사용된 변수 = 1 } }}``` " }, { "title": "C언어 공부 정리(4/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(4-2)/", "categories": "Language, C", "tags": "공부, C, 연습문제", "date": "2022-01-07 00:09:40 +0900", "snippet": "22/01/041. right circular shift 프로그램 right circular shift : 주어진 정수의 비트를 오른쪽으로 n번 이동 ex) 10 3(입력) → 00000000000000000000000000001010 (원본)                         01000000000000000000000000000001 (결과) -10 3(입력) → 11111111111111111111111111110110 (출력)                           11011111111111111111111111111110 (결과) 조건 scanf() 사용 원본과 결과 모두 2진수로 출력 오른쪽으로 이동되는 비트가 0이면 0추가, 1이면 1추가 #include &amp;lt;stdio.h&amp;gt;int main() { // 변수 선언 scanf(&quot;%d %d&quot;, &amp;amp;num, &amp;amp;n); // 원본 2진수 출력 for (i=0; i&amp;lt;n; i++) { // right circular shift } // shift 결과 출력 return 0;}소스 코드#include &amp;lt;stdio.h&amp;gt;int main() { int num, n, i; unsigned int check = 0x80000000; // 1000...0000 int rcheck = 0x7FFFFFFF; // 0111...1111 scanf(&quot;%d %d&quot;, &amp;amp;num, &amp;amp;n); // 원본 2진수 출력 for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) putchar(&#39;0&#39;); else putchar(&#39;1&#39;); check = check &amp;gt;&amp;gt; 1; } putchar(&#39;\\n&#39;); check = 0x80000000; // 1. right circular shift for (i=0; i&amp;lt;n; i++) { if (num &amp;gt;= 0) { // 2.양수 if ((num&amp;amp;1) == 0) // 2-1. 끝 비트가 0인가? num = num &amp;gt;&amp;gt; 1; else { // 2-2. 1인가? num = num &amp;gt;&amp;gt; 1; num |= check; } } else { // 3. 음수 if ((num&amp;amp;1) == 0) { num = num &amp;gt;&amp;gt; 1; num &amp;amp;=rcheck; // 3-1. 음수에서 rcs 시 0 추가하기 } else num = num &amp;gt;&amp;gt; 1; } } // shift 결과 출력 for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) putchar(&#39;0&#39;); else putchar(&#39;1&#39;); check = check &amp;gt;&amp;gt; 1; } putchar(&#39;\\n&#39;); return 0;} right circular shift 시 경우의 수 양수 0000..0010 &amp;gt;&amp;gt; 1 → 0000..0001 : 0이 자연스럽게 추가 됨 0000..0001 &amp;gt;&amp;gt; 1 → 1000..0000 : 1이 추가되어야 함 음수 1000..0001 &amp;gt;&amp;gt; 1 → 1100..0000 : 1이 자연스럽게 추가 됨 1000..0000 &amp;gt;&amp;gt; 1 → 0100..0000 : 0이 추가되어야 함 양수일 경우 양수의 끝자리 비트가 0인 경우(num&amp;amp;1) 자연스럽게 0이 추가됨으로 shift만 사용 양수의 끝자리 비트가 1인 경우 어떠한 상황에서도 1을 추가해 줘야 한다.(언제나 T) 0, 1 → 1 1, 1 → 1 한 가지라도 1(T)이라면 1(T)로 표현하는 |로 쉬프트 후 1000..0000 추가 음수일 경우 음수의 끝자리 비트가 0인 경우 어떠한 상황에서도 0을 추가해 줘야 한다.(언제나 F) 0, 0 → 0 1, 0 → 0 한 가지라도 0(F)이라면 0(F)으로 표현하는 &amp;amp;로 쉬프트 후 0111..1111 추가 음수의 끝자리 비트가 1인 경우(num&amp;amp;1) 자연스럽게 1이 추가됨으로 shift만 사용 실행 순서 양수 4 3 입력     0000…0100 &amp;amp; 0000…0001 (check) -------------------                            F num &amp;gt;&amp;gt; 1     0000…0010 &amp;amp; 0000…0001 (check) -------------------                            F num &amp;gt;&amp;gt; 1     0000…0001 &amp;amp; 0000…0001 (check) -------------------                            T num &amp;gt;&amp;gt; 1 0000…0000 num |= check ( 0000…0000 | 1000…0000 ) 결과 00000000000000000000000000000100 10000000000000000000000000000000 음수 -2 2 입력     1111…1110 &amp;amp; 0000…0001 (check) -------------------                            F num &amp;gt;&amp;gt; 1 1111…1111 num &amp;amp;= rcheck ( 1111…1111 &amp;amp; 0111…1111)     0111…1111 &amp;amp; 0000…0001 (check) -------------------                            T num &amp;gt;&amp;gt; 1 결과 11111111111111111111111111111110 10111111111111111111111111111111 2. 10진수를 2진수로 변환하는 함수 만들기 이전에 연습했던 10진수 → 2진수 프로그램을 함수로 만들고 left circular shift를 실행하시오 조건 함수명 : bi_print 리턴타입 : void main에서 scanf()로 정수를 받고 bi_print()로 2진수 출력 #include &amp;lt;stdio.h&amp;gt;// 함수 선언int main() { // 변수 선언 scanf(&quot;%d n&quot;, num, n); // 원본 2진법 출력; // left circular shift // left circular shift 출력; return 0;}// 함수 정의소스 코드#include &amp;lt;stdio.h&amp;gt;void bi_print(int); // 함수 선언int main() { int num, n; unsigned int check = 0x80000000; scanf(&quot;%d n&quot;, num, n); // 원본 2진법 출력; bi_print(num); // left circular shift for (i=0; i&amp;lt; n;i++) { if ((num&amp;amp;check)==0) { num = num &amp;lt;&amp;lt; 1; } else { num = num &amp;lt;&amp;lt; 1; num |= 1; } } // left circular shift 출력; bi_print(num); return 0;}// 함수 정의void bi_print(int num) { int i; unsigned int check = 0x80000000; // main의 check와는 별개의 변수 for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) putchar(&#39;0&#39;); else putchar(&#39;1&#39;); check = check &amp;gt;&amp;gt; 1; } putchar(&#39;\\n&#39;);}이전 코드의 main 길이 비교3. left circular shift 함수 만들기 위의 코드에서 left circular shift 코드도 함수로 만드시오 조건 함수명 : lcs 리턴타입 : int 소스 코드#include &amp;lt;stdio.h&amp;gt;void bi_print(int);int lcs(int, int); // 함수 선언int main() { int num, n; scanf(&quot;%d n&quot;, num, n); // 원본 2진법 출력; bi_print(num); // left circular shift num = lcs(num, n); // left circular shift 출력; bi_print(num); return 0;}// 함수 정의void bi_print(int num) { int i; unsigned int check = 0x80000000; for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) putchar(&#39;0&#39;); else putchar(&#39;1&#39;); check = check &amp;gt;&amp;gt; 1; } putchar(&#39;\\n&#39;);}int lcs(int num, int n) { int i; unsigned int check = 0x80000000; for (i=0; i&amp;lt; n;i++) { if ((num&amp;amp;check)==0) { num = num &amp;lt;&amp;lt; 1; } else { num = num &amp;lt;&amp;lt; 1; num |= 1; } }}이전 코드의 main 길이 비교" }, { "title": "C언어 공부 정리(4/10)-함수", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(4-1)/", "categories": "Language, C", "tags": "공부, C, 함수", "date": "2022-01-06 21:23:10 +0900", "snippet": "22/01/041. 함수 종류 Built in function = Library(미리 제공된 함수) 사용자 정의 함수2. 함수의 선언과 정의1. 선언 함수의 정보를 보여줌 선언 시 세미콜론으로 끝내주기; 일반적으로 main()위에 선언 main()에서 사용하는 함수를 쉽게 알 수 있음 주석을 세밀하게 달아서 함수의 코드를 보지 않아도 어떤 함수인지 알 수 있게 하는 것이 좋다. 의미 있는 이름으로 짓기 ex) “love”라는 문자열 출력 함수 » printLove(); 선언 방법 int func(int, int); // 주로 사용// orint func(int x, int y);// int - 리턴되는 데이터 타입// func - 함수 이름// (int x, int y) - 함수에 사용되는 요소의 데이터 타입과 개수int main() {} 2. 정의 함수의 기능 작성 main()아래에 입력 정의 작성 시 선언의 이름 없는 요소(int)와 다르게 이름을 꼭 붙여줘야 함(int x) 함수 실행에 여러 요소가 있다면 어떤 요소가 무슨 역할을 하는지 지정해 줘야 한다. 컴퓨터는 멍청하다 예시 int main () {} // int func(int, int) {} (X) int func(int x, int y) { x = 10; y = 20; printf(&quot;%d&quot;, x + y);} 3. 함수 사용하기#include &amp;lt;stdio.h&amp;gt;void printLove();int main() { printLove(); // 함수 실행}void printLove() { printf(&quot;love\\n&quot;);}결과 : love" }, { "title": "C언어 공부 정리(3/10)-연습문제", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(3)/", "categories": "Language, C", "tags": "공부, C, 연습문제", "date": "2022-01-05 00:50:30 +0900", "snippet": "22/01/031. 16진법을 10진수로 출력하는 프로그램(22/01/06 추가) ex) 42C(입력) → 1068(출력) 조건 getchar() 사용(입력) 입력 끝은 ‘\\n’ 단순변수로 해결할 것 한 자리씩 10진수로 변환 후 누적된 결과로 출력 출력 : printf(); #include &amp;lt;stdio.h&amp;gt;// exit() 사용#include &amp;lt;stdlb.h&amp;gt; int main() { // 변수 선언 while ((c=getchar()) !=&#39;\\n&#39;) { if (c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c&amp;lt;=&#39;9&#39;) // 숫자 변환 else if(c&amp;gt;=&#39;A&#39; &amp;amp;&amp;amp; c&amp;lt;=&#39;F&#39;) // 슷지 변환 else { printf(&quot;16진수가 아닙니다\\n&quot;); exit(1); // 강제 종료 } // 누적된 결과 저장 } printf(&quot;%d\\n&quot;, value); return 0;}소스 코드#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlb.h&amp;gt; int main() { char c; // 문자 입력 받을 변수 int num; // char를 int로 변경하기 위한 변수 int value = 0; // getchar()가 \\n이 아닐 동안 계속 반복 while ((c=getchar()) !=&#39;\\n&#39;) { if (c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c&amp;lt;=&#39;9&#39;) num = c - &#39;0&#39;; // 1. c = ascii code, 묵시적 형변환 else if(c&amp;gt;=&#39;A&#39; &amp;amp;&amp;amp; c&amp;lt;=&#39;F&#39;) num = c - &#39;A&#39; + 10; else { printf(&quot;16진수가 아닙니다\\n&quot;); exit(1); // 강제 종료 } // 2. 16진법 -&amp;gt; 10진법 변경 value = value * 16 + num; } printf(&quot;%d\\n&quot;, value); return 0;}+ getchar() : 한 문자만 받는다. + scanf(“포맷”, 변수주소) : 문자 또는 문자열을 받는다. 16진수 : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F A : 10진수의 10 F : 10진수의 15 char = 1문자, ascii code를 사용 ascii code = 0 ~ 127까지의 번호로 저장되어 있는 문자코드 ‘0’입력 시 &amp;gt;&amp;gt; num = 48(0의 ascii code) - 48 &amp;gt;&amp;gt; num = 0; ‘5’입력 시 &amp;gt;&amp;gt; num = 53 - 48 &amp;gt;&amp;gt; num = 5; ‘D’입력 시 &amp;gt;&amp;gt; num = 69 - 65 + 10 &amp;gt;&amp;gt; num = 14; 10진법과 16진법 10진법의 숫자 : 0,1,2,3,4,5,6,7,8,9 16진법의 숫자 : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F 3825(10) → 3 x 1000 + 8 x 100 + 2 x 10 + 5 x 1(100) 이전 자리수에 비해 다음 자리수는 10배 커진다. ( value * 10 ) 이전 숫자 + 다음 숫자 &amp;gt;&amp;gt; value * 10 + num(이전 숫자) 0 x 10 + 3 &amp;gt;&amp;gt; 3 x 10 + 8 &amp;gt;&amp;gt; 38 x 10 + 2 &amp;gt;&amp;gt; 382 x 10 + 5 &amp;gt;&amp;gt; 3825 16진법의 10진법 변환법 12A(16) → 1 x 162 + 2 x 161 + 10 x 160 → 298(10) 16진법을 10진법으로 변환하기 위해 16을 곱하고 다음 숫자를 더함 ( value * 16 + num) 실행순서 (예시)12C입력 ‘1’ &amp;gt; 1 value = 0 * 16 + 1 &amp;gt;&amp;gt; value = 1 ‘2’ &amp;gt; 2 value = 1 * 16 + 2 &amp;gt;&amp;gt; value = 18 ‘C’ &amp;gt; 12 value = 18 * 16 + 12 &amp;gt;&amp;gt; value = 300 결과 : 3002. 10진수를 2진수로 출력하는 프로그램 ex) 10(입력) → 00000000000000000000000000001010 (출력) -10(입력) → 11111111111111111111111111110110 (출력) 조건 scanf() 사용(입력) 비트 연산자 이용 한 비트씩 체크 결과 0이면 putchar(‘0’) or printf(“0”), 1이면 putchar(‘1’) or printf(“1”) include &amp;lt;stdio.h&amp;gt;int main() { // 변수선언 scanf(&quot;%d&quot;. &amp;amp;num); for (i=0; i&amp;lt;32; i++) { // num의 한 비트씩 체크해 0 또는 1 출력 } return 0;}소스 코드include &amp;lt;stdio.h&amp;gt;int main() { int num; // 숫자 입력받을 변수 int i; // for문 변수 // 1. 비트 체크를 위한 변수 unsigned int check = 0x80000000; // 1000...0000 // 2. scanf(&quot;포맷&quot;, 변수 주소); scanf(&quot;%d&quot;, &amp;amp;num); // 3. int = 32 bit for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) // 숫자와 check 확인결과 0일 경우 putchar(&#39;0&#39;); else // 숫자와 check 확인결과 1일 경우 putchar(&#39;1&#39;); // 4. 다음 비트를 확인하기 위한 shift check = check &amp;gt;&amp;gt; 1; } putchar(&#39;\\n&#39;); return 0;} 프로그램에서 출력되는 숫자는 10진법이지만 컴퓨터는 2진법으로 인식 1(출력) : 00000000000000000000000000000001(인식) 왼쪽에서부터 한 비트씩 (0 or 1)을 출력하기 위한 변수 *unsigned : 음수가 없는 정수 데이터를 입력받을 수 있는 함수 변수의 주소로 값을 가져올 수 있다. &amp;amp;변수 : 변수의 주소값 입력받은 정수를 한 비트씩 이진법으로 출력하기 위해 for문으로 32번 반복 다음 비트를 확인하기 위한 shift &amp;gt;&amp;gt; : 비트가 오른쪽으로 이동 ex) 0110 &amp;gt;&amp;gt; 2 → 0001 check를 일반 정수 데이터로 선언 시, 첫 비트가 1이므로 음수 로 인식 양수의 &amp;gt;&amp;gt; : 빈 공간은 0으로 채워짐 음수의 &amp;gt;&amp;gt; : 빈 공간은 1로 채워짐(음수인 것을 유지해야 함으로) &amp;gt;&amp;gt;연산자 사용 시 0이 오게끔 하기 위해 음수가 없는 *unsigned로 선언 실행 순서 (예시)15 입력     0000 00…00 1111 (15)&amp;amp; 1000 00…00 0000 (check)------------------------------    F check &amp;gt;&amp;gt; 1 (1비트 이동)     0000 00…00 1111 (15)&amp;amp; 0100 00…00 0000 (check)------------------------------        F check &amp;gt;&amp;gt; 1     0000 00…00 1111 (15)&amp;amp; 0010 00…00 0000 (check)------------------------------          F                            … check &amp;gt;&amp;gt; 1     0000 00…00 1111 (15)&amp;amp; 0000 00…00 1000 (check)------------------------------                            T 결과 00000000000000000000000000001111 3. left circular shift 프로그램 left circular shift : 주어진 정수의 비트를 왼쪽으로 n번 이동 ex) 10 3(입력) → 00000000000000000000000000001010 (원본)                         00000000000000000000000001010000 (결과) -10 3(입력) → 11111111111111111111111111110110 (출력)                           11111111111111111111111110110111 (결과) 조건 scanf() 사용 입력된 데이터의 원본과 결과물 모두 2진수로 출력 왼쪽으로 이동 시 비트가 0이면 0추가, 1이면 1추가 ex) 1011 0000 « 3 → 1000 0101 #include &amp;lt;stdio.h&amp;gt;int main() { // 변수 선언 scanf(&quot;%d %d&quot;, &amp;amp;num, &amp;amp;n); // 입력된 원본 2진수 출력 for (i=0; i&amp;lt;n;i++) { // left circular shift } // shift 결과 출력 return 0;}소스 코드#include &amp;lt;stdio.h&amp;gt;int main() { int num; int n; int i; unsigned int check = 0x80000000; scanf(&quot;%d %d&quot;, &amp;amp;num, &amp;amp;n); // 원본 2진수 출력 for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) putchar(&#39;0&#39;); else putchar(&#39;1&#39;); check = check &amp;gt;&amp;gt; 1; } putchar(&#39;\\n&#39;); // 위에서 check가 shift로 인해 0이 되었으므로 다시 값 선언 check = 0x80000000; // 1. left circular shift for (i=0; i&amp;lt; n;i++) { // 2. check 결과 0이면 shift if ((num&amp;amp;check)==0) { num = num &amp;lt;&amp;lt; 1; } // 3. check 결과 1이면 shift 후 1 추가 else { num = num &amp;lt;&amp;lt; 1; num |= 1; } } // shift 결과 출력 for (i=0; i&amp;lt;32; i++) { if((num&amp;amp;check) == 0) putchar(&#39;0&#39;); else putchar(&#39;1&#39;); check = check &amp;gt;&amp;gt; 1; } return 0;} n번만큼 왼쪽으로 이동하기 위해 조건을 i&amp;lt;n으로 설정 &amp;lt;&amp;lt; 실행 시 비어있는 공간은 자동으로 0으로 채워짐 ex) 0010 « 1 → 0100 num과 check 결과 0이면 다른 실행문 없이 shift만 사용 num과 check 결과 1이면 0이 아닌 1을 추가해야 함으로 1이라는 정보 추가 int x = 8 → 1000 x |= 1 → 1000 + 0001 = 1001 실행순서 -15 4 입력     1111 11…1111 0001&amp;amp; 1000 00…0000 0000 (check)---------------------------------    T num « 1 (1비트 이동)     1111 11…1110 0011 &amp;amp; 1000 00…0000 0000 (check)---------------------------------    T num « 1     1111 11…1100 0111&amp;amp; 1000 00…0000 0000 (check)---------------------------------    T num « 1     1111 11…1000 1111&amp;amp; 1000 00…0000 0000 (check)---------------------------------    T num « 1 결과 1111111111111111111111111111000111111111111111111111111100011111 " }, { "title": "C언어 공부 정리(2/10)-제어문", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(2-2)/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-02 19:09:00 +0900", "snippet": "21/12/301. if문1) 기본 문법if ( 조건 ) { 실행문;} 조건이 참일 경우 실행문을 수행 조건이 거짓일 경우 if문을 빠져나온다.2) elseif ( 조건 ) { 실행문;}else { 실행문;} 조건의 거짓일 경우 else 실행문 수행3) else ifif ( 조건1 ) { 실행문1;}else if ( 조건2 ){ 실행문2;} else { 실행문3;} 조건1 = 참 : 실행문1 조건1 = 거짓, 조건2 = 참 : 실행문2 조건1 = 거짓, 조건2 = 거짓 : 실행문34) 중첩 if문 if문 안에 if문이 있는 경우 if ( 조건1 ) { if ( 조건2 ) { 실행문1; } else { 실행문2; }}else { 실행문3;} 조건1 = 참, 조건2 = 참 : 실행문1 조건1 = 참, 조건2 = 거짓 : 실행문2 조건1 = 거짓 : 실행문32. switch문문법switch( n ){ case value1 : 실행문1; break; case value2 : 실행문2; break; default : 실행문3;} n = int 또는 char n의 결과에 따라 실행되는 case가 달라진다. n = value1 : 실행문1 n = value2 : 실행문2 default : if문의 else와 같음break break 有 switch( n ) { case value1 : 실행문1; break; case value2 : 실행문2; break; default : 실행문3; } n = value2 : 실행문2 » switch문 빠져나옴 break 無 switch( n ) { case value1 : 실행문1; case value2 : 실행문2; default : 실행문3; } n = value2 : 실행문2, 실행문3 수행 3. while문문법while ( 조건 ){ 실행문;} 조건이 참일동안 실행문이 반복된다. ex) int i = 1;int n = 0;while (n &amp;lt; 10) // n = 10 &amp;gt;&amp;gt; while문 실행 x{ i += 1; n += 2;}printf(&quot;i = %d, n = %d&quot;, i, n); 수행 순서 i = 2, n = 2 i = 3, n = 4 i = 4, n = 6 i = 5, n = 8 i = 6, n = 10 결과 : i = 6, n = 10 중첩 whilewhile ( n ){ while ( m ) { 실행문; }} 가장 안쪽 while부터 실행4. do - while문 문법 do{ 실행문;} while ( 조건 ) 조건이 참일동안 실행문 수행5. for문문법for ( 초기식; 조건식; 증감식 ) { 실행문;} 초기식 초기식을 기준으로 조건과 증감식의 결과가 나온다. 주로 int = 0;을 사용한다. 조건식 초기식의 반복 조건. 조건식이 거짓이 되면 for문 종료 증감식 반복할 때 마다 초기식이 증감한다. ++ 혹은 --을 쓴다 ex) for (int i = 0; i &amp;lt; 10; i++) { printf(&quot;%d, &quot;, i);} 결과 : 1, 2, 3, 4, 5, 6, 7, 8, 9, 중첩 forint i;int j;for (i = 0; i &amp;lt;=5; i++ ) { // i가 5를 넘으면 for문 실행 x for (j = 0; j &amp;lt;=4; j++) { printf(&quot;i = %d, j = %d\\n&quot;, i, j); }}결과i = 0, j = 0i = 0, j = 1i = 0, j = 2i = 0, j = 3i = 0, j = 4i = 1, j = 0i = 1, j = 1       …i = 5, j = 0i = 5, j = 1i = 5, j = 2i = 5, j = 3i = 5, j = 46. Continue 조건으로 다시 돌아간다. ex) int sum = 0;for (int i=0; i&amp;lt;=6; i++) { if (i % 2 == 0) { continue; // 짝수일 경우 조건으로 돌아간다 } sum += i; // sum = sum + i; printf(&quot;%d번째 sum값 = %d\\n&quot;, i+1, sum);} 실행 순서 i = 0 » if : T » i++ i = 1 » if : F » sum += i; (sum=1), printf(), i++ i = 2 » if : T » i++ i = 3 » if : F » sum += i; (sum=4), printf(), i++ i = 4 » if : T » i++ i = 5 » if : F » sum += i; (sum=9), printf(), i++ i = 6 » if : T » i++ 결과 2번째 sum값 = 1 4번째 sum값 = 4 6번째 sum값 = 9 " }, { "title": "C언어 공부 정리(2/10)-연산자 종류", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(2-1)/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-02 04:00:30 +0900", "snippet": "21/12/300. 연산자의 우선순위 연산을 할 때 가장 먼저 계산되는 것 ~ 가장 나중에 계산되는 순서 1 + 1 * 2 = 3 ( 곱셈먼저 계산 ) (1 + 1 ) * 2 = 4 ( 괄호먼저 계산 ) 순서 () ⇒ 증감, !, (포인터), &amp;amp;(주소) ⇒ 사칙연산(, /, % ⇒ +, -) ⇒ 시프트 ⇒ 비교 ⇒ 비트 ⇒ 논리(&amp;amp;&amp;amp;, ||) ⇒ 대입 1. 산술연산자 (+, -, *, /, %) 사칙연산 % : 나머지 사용법 printf(&quot;%d&quot;,35%5); 결과 : 0 2. 증감연산자 (++, –) 피연산자를 1씩 증가 또는 감소 연산자의 위치에 따라 증감시점이 달라지므로 유의! ++a : a 증가시킨 후 연산 a++ : 연산 후 a 증가ex 1) int a, b; a = 4; b = ++a * ++a; ++a(1) * ++a(2) 연산순서   (1) a = 4 + 1   (2) a = 5 + 1   b = 6 * 6∴ a = 6, b = 36 ++a : 연산보다 우선순위가 높으므로 ++먼저 계산ex 2) int a, b; a = 10; b = a++ - a--; a++(1) - a--(2) 연산순서   b = 10 - 10   (1) a = 10 + 1   (2) a = 11 - 1∴ a = 10, b = 0 a++ : 연산 후 계산ex 3) int a, b, c; a = 3; b = 2; c = ++a + b++; ++a + b++ 연산순서   a = 3 + 1   c = 4 + b++   c = 4 + 2   b = 2 + 1∴ a = 4, b = 3, c = 6 ex 4) int a, b, c; a = 3; b = 2; c = a++ + ++b; a++ + ++b 연산순서   c = 3 + ++b   b = 2 + 1   c = 3 + 3   a = 3 + 1∴ a = 4, b = 3, c = 6 3. 대입연산자 (=, +=, -=, …)사용법int a = 25;a += 3; // a = a + 3printf(&quot;%d\\n&quot;, a);a -= 3; // a = a - 3printf(&quot;%d\\n&quot;, a); 결과  28  254. 비교연산자 (&amp;gt;, =&amp;gt;, &amp;lt;, &amp;lt;=, ==, !=..) 두 값의 비교 == : 두 값이 같은가? != → 부정! a != 9 » a는 9가 아니다 int num = 9; if(num != 9) { printf(&quot;거짓!&quot;); // num이 9가 아닐 경우 실행 } else { printf(&quot;참!&quot;); // num이 9가 아닌것 이외일 경우(num이 9라면) 실행 } 결과 : 참! 5. 논리연산자 (&amp;amp;&amp;amp;, ||, !)1) ! 부정! 논리 뒤집기! 참! = 거짓 거짓! = 참 1! = 0 (거짓) 0! = 1 (참) 컴퓨터 언어에서 0 이외의 숫자는 모두 참(True) 따라서 3! = False   22! = False 2) &amp;amp;&amp;amp; 거짓이 하나라도 있으면 false(F) 거짓 을 찾은 순간 뒤의 조건은 더이상 확인하지 않음 조건식 거짓유무 결과 T&amp;amp;&amp;amp;F O F F&amp;amp;&amp;amp;T O F T&amp;amp;&amp;amp;T X T 3) || 참이 하나라도 있으면 true(T) 참 을 찾은 순간 뒤의 조건은 더이상 확인하지 않음 조건식 참유무 결과 T||F O T F||T O T F||F X F 4) &amp;amp;&amp;amp;, || 조건이 3개 이상 ex ) T &amp;amp;&amp;amp; F &amp;amp;&amp;amp; T; { ( T &amp;amp;&amp;amp; F ) &amp;amp;&amp;amp; T } ⇒ { ( F ) &amp;amp;&amp;amp; T } ⇒ F F || T || F; { ( F || T ) || F } ⇒ { ( T ) || F } ⇒ T T || F &amp;amp;&amp;amp; T; { ( T || F ) &amp;amp;&amp;amp; T } ⇒ { ( T ) &amp;amp;&amp;amp; T } ⇒ T F &amp;amp;&amp;amp; F || T; { ( F &amp;amp;&amp;amp; F ) || T } ⇒ { ( F ) || T } ⇒ T 6. 비트연산자 (&amp;amp;, |, ~, ^)1) ~ 단항연산자 1의 보수로 변환 1011 » 0100 0010 » 1101 2) ^ 이항연산자 두 항의 값이 다르면 T, 같으면 F T ^ F = T F ^ T = T T ^ T = F F ^ F = F 3) &amp;amp;, | | : 정보추가 &amp;amp; : 정보추출 ex) 좌석 예약(long x) 미예약 : 0, 예약석 : 1 좌석32 … 좌석4 좌석3 좌석2 좌석1 0 … 0 0 0 0 좌석3 예약 :   x = 4 좌석32 … 좌석4 좌석3 좌석2 좌석1 0 … 0 1 0 0 좌석1 예약 :   x = x | 1 0...0100 + 0...0001------------ 0...0101 좌석32 … 좌석4 좌석3 좌석2 좌석1 0 … 0 1 0 1 x = 1 » 0…0001 (이전 데이터는 사라지고 새로운데이터(x=1)가 저장됨) 좌석1 예약확인 : if ( x &amp;amp; 1 ) { // x와 1 모두 T(1)인가? printf(&quot;예약되었습니다.&quot;); } else { // x가 F(0)인가? printf(&quot;예약되지 않았습니다.&quot;); } 좌석32 … 좌석4 좌석3 좌석2 좌석1 0 … 0 1 0 1 0 … 0 0 0 1 - … - - - T x에 1이 있는지 확인하고 결과 출력 결과 : 예약되었습니다 7. 시프트연산 («, ») 비트 연산자 1) « 비트 전체를 왼쪽으로 이동 사용법 int b = 0110 1010;printf(&quot;%d&quot;,b&amp;lt;&amp;lt;2);     0110 10100110 1010 «2칸 왼쪽으로 이동결과: 1010 1000 밖으로 나간 비트는 제거, 비어있는 부분은 0으로 채워짐 2) » 비트 전체를 오른쪽으로 이동 &amp;lt;&amp;lt;와 반대8. 간접연산자 (*) 포인터에 사용하는 연산자 아직 포인터를 배우지 않았음으로 대충 이해한대로 정리하자면 ‘*변수’의 주소 내용을 참조 사용법 참조 int *ptr;int num = 10;ptr = num;printf(&quot;%d&quot;,*ptr); 결과: 10 9. 주소연산자 (&amp;amp;) 변수의 주소를 알려주는 연산자 변수마다 고유의 주소를 가지고 있음 ⇒ 주소만으로 특정 변수를 알 수 있음(컴퓨터가) 사용법 int x = 5;scanf(&quot;%d\\n&quot;,&amp;amp;x); // scanf(&quot;포맷&quot;, 변수 주소);int arr[3] = {1, 2, 3};scanf(&quot;%d&quot;,arr); 결과5arr`address scanf() : 변수주소를 사용하지 않으면 에러! 인덱스 미지정 배열 출력 결과 : 변수의 주소 10. 형변환연산자 ( (변환할 타입) ) 명시적 형변환 정확히 어떤 데이터타입으로 변할지 지정해 주는 것묵시적 형변환 int x = 5;float y = x; // int가 암묵적으로 float로 변경됨 사용법 int x = 5;float y = (float)x; //int를 float로 지정 형변환 시 주의할 점 작은 타입 » 큰 타입 (괜찮음) 큰 타입 » 작은 타입 (결과가 달라질 수 있음) int x = (int)3.1;   » x = 3 연산자의 우선순위에 의해 결과가 달라질 수 있음 ( float ) 100 / 3 = 33.3333333 ( float ) ( 100 / 3 ) = 33.0000000 11. 삼항연산자 (조건 ? 참 : 거짓;) 세 개의 항으로 이루어진 연산자 사용법 // ( 조건 ) ? 참 : 거짓;(3 == 4) ? printf(&quot;True&quot;) : printf(&quot;False&quot;); 결과 : False 12. 괄호연산자 ( (), [], {} ) 우선순위가 가장 높은 연산자 우선순위를 잘 모르겠다면 괄호로 순서를 정하는것도 좋음" }, { "title": "C언어 공부 정리(1/10) + 추가", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(1)-%EC%B6%94%EA%B0%80/", "categories": "Language, C", "tags": "공부, C", "date": "2022-01-01 16:17:41 +0900", "snippet": "1. 배열 선언&amp;amp;초기화! int numArr[5] = {23, 6, 99, 143, 40}; 출력! printf(&quot;%d\\n&quot;, numArr[0]); // numArr의 첫번째 값 출력printf(&quot;%d\\n&quot;, numArr[4]); // numArr의 5번째 값 출력printf(&quot;%d\\n&quot;, numArr[2]); // numArr의 3번째 값 출력// \\n : 줄바꿈 표시(enter) 결과234099 ‘0’부터 index 시작 배열 초기화시 크기보다 값 개수가 적은것은 괜찮으나 넘으면 에러!2. ‘문자’ / “문자열” 하나의 문자를 표현 할 때는 &#39;&#39; 둘 이상의 문자열을 표현 할 때는 &quot;&quot; 문자 ‘1’ = ‘1’ ‘T’ = ‘T’ 문자열 “32” = ‘3’ ‘2’ “web” = ‘w’ ‘e’ ‘b’ 하나의 ‘문자’를 “문자열”로 하는것은 가능 “x” = ‘x’ ‘\\0’    // ‘\\0’ → Null 3. printf() C언어의 출력함수 여러 종류의 데이터 포맷으로 출력할 수 있다. printf(&quot;%d\\n&quot;,65.3); // %d : intprintf(&quot;%f\\n&quot;,65.3); // %f : float, doubleprintf(&quot;%c\\n&quot;,65); // %c : charprintf(&quot;Hello, World!&quot;); 결과6565.3AHello, World! 4. 이진법 음수표현1) 부호와 절대치 비트의 첫 번째가 0이면 양수, 1이면 음수 int 10; » 0000 ···00 1010 int -10; » 1000 ···00 10102) 1의 보수 0 → 1 1 → 00010 ···11 0110을1101 ···00 1001로 변경3) 2의 보수 주로 사용하는 방법 1의 보수 + 1 ex) 0010 ···11 0110→ 1101 ···00 1001 + 1→ 1101 ···00 10105. 실수 - 부동소수점1) 실수 표현방식 241.857 = 0.241857 x 103 241857 : 가수부 103 : 지수부 12.45 = 0.1245 x 102 1245 : 가수부 102 : 지수부 8.72 = 0.872 x 101 872 : 가수부 101 : 지수부 2) 비트 구조 (-1)s x 2E x M (-1)s : 부호부(+/-) » 1bit 2E : 지수부 » 8bit M : 가수부 » 23bit컴퓨터의 실수 표현방법       5.25   5 → 101(2)   0.25 → 01(2)   5.25 → 101.01(2)   101.01(2) → 1.0101(가수) x 22(지수)   가수의 좌측 끝은 언제나 1이므로 그 다음부터만 가수부에 저장 → 0101   (22의 지수)2 + 127(지수부(8bit)의 *bias) = 129   지수부에 129 저장 → 1000 0001(2)   5.25는 양수이므로 부호부 → 0 ∴ 5.25 → 0 10000001 01010000000000000000000(2) *bias : 2k-1 - 1 (k=지수부의 비트수)참고자료부동소수점 Wikipedia Codetorial" }, { "title": "C언어 공부 정리(1/10)", "url": "/posts/C%EC%96%B8%EC%96%B4-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC(1)/", "categories": "Language, C", "tags": "공부, C", "date": "2021-12-31 23:04:56 +0900", "snippet": "21/12/291. C언어 파일 fileName.h : Library fileName.c : source file2. C언어 기본 구성// 사용할 라이브러리#include &amp;lt;file.h&amp;gt; // main() : 프로그램 시작과 끝int main(void) { printf(&quot;Hello, World!\\n&quot;); return 0;}- include &amp;lt; file.h &amp;gt; : 기본적으로 제공되는 라이브러리 “file.h” : 내가 만든 라이브러리- main() 한 프로그램에 하나만 존재- 문장 끝은 언제나 세미콜론; 안쓰면 에러! int x //하지만 에러원인은 여기지int y; // 에러 발생지점; 3. ascii code 알파벳, 숫자, 특수기호의 정보(128개)를 가지고 있는 문자 인코딩 C는 ascii code를 사용 문자 ascii code ‘A’ 65 ‘0’ 48 4. 변수종류- 단순변수(변수) 하나의 데이터만 기억 선언 방법 int x; // 정수char y; // 문자 - 배열변수(배열) 하나의 변수에 여러 개의 값 저장 선언 방법 int x[10]; // 정수 10개까지 저장가능char y[5]; // 문자 5개까지 저장가능 - Structure(구조체)Structure- 변수 명명법 공백, 특수문자(_예외)사용불가 공백 필요 시 &quot;_&quot;사용 » int my_byunsu; 또는 대문자로 구분 » int myByunsu; 숫자 사용가능, 하지만 숫자로 시작하는 것은 불가 int 1num; (X) int num1; (O) 키워드 사용불가(if, int, void, … etc) 대소문자 구분 int aBc; ≠ int ABc; 첫 문자로 언더바(_) 사용 시 라이브러리 변수랑 충돌날 수 있음! 주의! stdio.h파일의 &#39;_변수&#39; 5. 변수 초기화 변수를 선언하고 그 변수에 유효한 값을 설정하는 것 int x; // 변수 선언x = 10; // 초기화int y = 10; // 변수 선언과 동시에 초기화 6. 상수 변하지 않는 숫자 ★수.정.불.가★ ex) PI ≡ 3.14159265359… 선언 방법 const int SAMPLE = 2000; 명명법(약속) : 대문자만 사용하기7. 주석 설명을 위해 사용 프로그램에 아무런 영향을 미치지 않는다. 코드를 임시로 삭제시 사용하기도 한다. // 한 줄 주석/* 여러 줄 주석 여기도 주석 저기도 주석 주석이 콸콸콸*/int x;// x = 10; &amp;gt;&amp;gt; 코드 임시 제거 주석은 남을 위해, 미래의 나를 위해 꼼꼼하게 적는 것이 좋다.8. 데이터타입(기본형)1) 정수형(int) 소수점 이하를 가지고 있지 않는 숫자 종류 음수표현 바이트 short O 2 int O 4 long O 8 unsigned short X 2 unsigned int X 4 int는 생략됨 (short int -&amp;gt; short) 선언! int x;short y;int l,m,n; // 여러 개 동시 선언! 출력! int num = 23;printf(&quot;%d&quot;,num); // printf(&quot;포맷&quot;,변수); 결과: 23 2) 실수형 소수점 이하를 가지고 있는 숫자 종류 바이트 정밀도 float 4 6자리 double 8 15자리 long double 8↑ 15자리↑ 선언! float f = 1.2;double d = 3.3; 출력! printf(&quot;%f&quot;,d); 결과: 3.3 3) 문자형(char) 하나의 문자 또는 기호를 표현 ascii code 사용 문자 표현 시 반드시 작은 따옴표(‘ ‘) 사용 선언! char A=&#39;A&#39;, C=&#39;C&#39;; // 동시 선언 &amp;amp; 초기화char chr;chr = &#39;B&#39;; 출력! printf(&quot;%c&quot;,chr); 결과: B " }, { "title": "포스트 작성 연습", "url": "/posts/%ED%8F%AC%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1-%EC%97%B0%EC%8A%B5/", "categories": "Blog", "tags": "연습", "date": "2021-12-30 20:57:29 +0900", "snippet": "Chirpy Theme 사용1. 포스트 파일 생성 파일 생성 위치: _posts/ 파일명YYYY-MM-DD-TITLE.md or YYYY-MM-DD-TITLE.markdown 2. 파일 내부 최상위에 작성해야 할 것---title: Titledate: YYYY-MM-DD HH:MM:SS +0900 # +0900 한국시간categories: [main_category, sub_category]tags: [tag] # 0개~---3. 마크다운 문법- header size# h1## h2### h3#### h4##### h5###### h6h1h2h3h4h5h6- text decoration 이태릭체Italic Italic *Italic*_Italic_ 굵음boldbold **bold**__bold__ 굵은 이태릭체italic &amp;amp; bold **_italic &amp;amp; bold_** 취소선cancle ~~cancle~~ 밑줄underScore &amp;lt;u&amp;gt;underScore&amp;lt;/u&amp;gt; 하이라이트highlight &amp;lt;mark&amp;gt;highlight&amp;lt;/mark&amp;gt; - List 순서 有 하나 하나 하나 1. 하나 2. 하나 3. 하나 순서 無 하나 하나 하나 # 결과는 모두 동일 - 하나 * 하나 + 하나 # tab에 따라 모양 달라짐- Linkhttps://www.google.com/ 구글&amp;lt;https://www.google.com/&amp;gt;[구글](https://www.google.com/)" } ]
